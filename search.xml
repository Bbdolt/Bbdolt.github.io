<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第八篇</title>
      <link href="/2024/10/17/%E7%AC%AC%E5%85%AB%E7%AF%87/"/>
      <url>/2024/10/17/%E7%AC%AC%E5%85%AB%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> TEA系列算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day2 十分钟带你解决逆向中对称加密算法 (RC4)</title>
      <link href="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/"/>
      <url>/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="流加密算法"><a href="#流加密算法" class="headerlink" title="流加密算法"></a>流加密算法</h4><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流加密算法（Stream Cipher），是一种加密方式，它通过将明文与一个随机生成的密钥流进行逐位或逐字节异或操作来产生密文。</span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">密钥流生成器（Key Stream Generator）：流加密算法的核心是密钥流生成器，它使用一个短的密钥（种子密钥）</span><br><span class="line">来生成一个长的密钥流。这个密钥流决定了加密的随机性和强度。</span><br><span class="line"></span><br><span class="line">异或操作（XOR Operation）：明文数据与密钥流进行异或操作，生成密文。解密时，密文与同一密钥流再次进行</span><br><span class="line">异或操作，恢复出明文。</span><br></pre></td></tr></table></figure><h4 id="RC4算法介绍"><a href="#RC4算法介绍" class="headerlink" title="RC4算法介绍"></a>RC4算法介绍</h4><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种串流加密算法，密钥长度可变。他加密解密使用</span><br><span class="line">相同的密钥，因此也被称为“流加密算法”。RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，</span><br><span class="line">范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。</span><br><span class="line">S盒用来加密数据，而且在加密过程中S盒会变化。由于异或运算的对合性，RC4加密解密使用同一套算法。</span><br></pre></td></tr></table></figure><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、初始化S-Box</span><br><span class="line">2、KSA过程（置乱刚刚初始化完成的S表）</span><br><span class="line">  - 初始化密钥（可无可有）</span><br><span class="line">  - 置乱过程（KSA）</span><br><span class="line">3、PRGA过程（生成密钥流，用于与明文进行异或生成密文）</span><br></pre></td></tr></table></figure><h4 id="RC4算法刨析"><a href="#RC4算法刨析" class="headerlink" title="RC4算法刨析"></a>RC4算法刨析</h4><h4 id="第一步：初始化S-Box"><a href="#第一步：初始化S-Box" class="headerlink" title="第一步：初始化S-Box"></a>第一步：初始化S-Box</h4><p>具体过程如下图所示，其实就是从0~255填充满大小为256的数组。<br><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/1.png"></p><h4 id="第二步：KSA过程"><a href="#第二步：KSA过程" class="headerlink" title="第二步：KSA过程"></a>第二步：KSA过程</h4><h4 id="初始化密钥"><a href="#初始化密钥" class="headerlink" title="初始化密钥"></a>初始化密钥</h4><p>上面我们有了最初的S-Box，那么对于KSA的核心作用呢，实际上是通过密钥来置乱初始的向量，这个初始向量是一个固定值，从0~255来填充满S-Box。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这一步呢其实在编码过程当中是可有可无的，如果我们不生成T-Box，可以在编码过程当中模KeyLen来实现，如果使用T-Box，那么我们在编码过程当中需要模256了，这里展示使用T-Box的情况，和文章最开头的流程图保持一致。对于T-Box来说，其实就是密钥循环复制m次，使得循环之后充满256长度的数组，从这里可以直观的看出，对于RC4来说，它的密钥长度大小最大是256。</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/2.jpg"></p><h4 id="置乱过程-KSA"><a href="#置乱过程-KSA" class="headerlink" title="置乱过程(KSA)"></a>置乱过程(KSA)</h4><p><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/3.jpg"></p><h4 id="KSA整体流程图"><a href="#KSA整体流程图" class="headerlink" title="KSA整体流程图"></a>KSA整体流程图</h4><p><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/4.png"></p><h4 id="第三步：PRGA过程"><a href="#第三步：PRGA过程" class="headerlink" title="第三步：PRGA过程"></a>第三步：PRGA过程</h4><p>这个过程是整个RC4算法的核心，通过这个过程生成我们需要的PRNG序列，具体过程如下图所示。<br><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/5.jpg"></p><h4 id="PRGA整体流程图"><a href="#PRGA整体流程图" class="headerlink" title="PRGA整体流程图"></a>PRGA整体流程图</h4><p><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/6.png"></p><h4 id="解决逆向中对称加密算法的小技巧"><a href="#解决逆向中对称加密算法的小技巧" class="headerlink" title="解决逆向中对称加密算法的小技巧"></a>解决逆向中对称加密算法的小技巧</h4><h4 id="使用工具："><a href="#使用工具：" class="headerlink" title="使用工具："></a>使用工具：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LazyIDA：具体可以看我的bilibili上的视频教程，提供插件下载。</span><br><span class="line"></span><br><span class="line">主要作用：</span><br><span class="line">自动重定位跳转</span><br><span class="line">数据格式转换</span><br><span class="line">粘贴数据到指定内存</span><br><span class="line">DUMP指定内存到文件</span><br><span class="line">修改内存数据</span><br></pre></td></tr></table></figure><h4 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">首先我们知道流加密算法的加密和解密过程是相同的，我们输入的明文会被加密为密文，那么如果我们输入</span><br><span class="line">的是密文那么得到是不是就是我们要的明文，所以我们要想办法获得密文，一般逆向过程是，我们输入字符串</span><br><span class="line">然后程序进行加密，得到加密后的密文，与正确的flag密文进行比较，如果相同，那么则正确。</span><br><span class="line"></span><br><span class="line">那么我们可以使用LazyIDA中带有提取特定数据格式和修改内存数据的功能，通过提取内存中的密文，然后作为</span><br><span class="line">输入，进行解密，得到flag，因为提取的密文可能会带有不可见字符，所以需要LazyIDA插件。</span><br><span class="line"></span><br><span class="line">具体可以看我的bilibili上的视频教程，有例题讲解。</span><br></pre></td></tr></table></figure><h4 id="bilibili视频教程"><a href="#bilibili视频教程" class="headerlink" title="bilibili视频教程"></a>bilibili视频教程</h4><p><a href="https://www.bilibili.com/video/BV1i3xDeZE7H/?share_source=copy_web&vd_source=cb1799ab55ca5d1f2c72c3c2c11d5e74">十分钟带你解决逆向中对称加密算法（RC40)</a></p>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> RC4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>番外篇：网鼎杯2020 signal（Ponce插件的使用）</title>
      <link href="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/"/>
      <url>/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="VM知识："><a href="#VM知识：" class="headerlink" title="VM知识："></a>VM知识：</h4><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/10.png"></p><p>分析流程：<br><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/11.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm_start :虚拟机入口函数 ，初始化虚拟机</span><br><span class="line">vm_dispatcher: 调度器，解释op_code,并选择相应的函数执行，当函数执行完后会返回这里，形成一个循环，直到执行完</span><br><span class="line">vm_code:程序可执行代码形成的操作码</span><br></pre></td></tr></table></figure><h4 id="Ponce的简述："><a href="#Ponce的简述：" class="headerlink" title="Ponce的简述："></a>Ponce的简述：</h4><p>对于Ponce来说只需要关心那里输入，哪里success，哪里wrong。<br>Ponce是一款IDAPro插件，该工具采用C&#x2F;C++开发，它可以帮助用户以一种快速简洁的方式对目标代码进行<br>污点测试以及符号执行。用户只需点一下鼠标或者按一下键盘，剩下的就可以交给Ponce了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + M ：符号化（找到输入的参数将其变为符号变量）</span><br></pre></td></tr></table></figure><h4 id="符号执行："><a href="#符号执行：" class="headerlink" title="符号执行："></a>符号执行：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">传统符号执行是一种静态分析技术，最初在1976年由King JC在ACM上提出。即通过使用抽象的符号代替具体值来模拟程序的执行，当遇到分支语句时，它会探索每一个分支, 将分支条件加入到相应的路径约束中，若约束可解，则说明该路径是可达的。</span><br><span class="line"></span><br><span class="line">在遇到程序分支指令时, 程序的执行也相应地搜索每个分支, 分支条件被加入到符号执行保存的符号路径约束 PC, PC表示当前路径的约束条件。在收集了路径约束条件之后, 使用约束求解器来验证约束的可解性, 以确定该路径是否可达。若该路径约束可解, 则说明该路径是可达的;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大概原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">符号：符号是代表一组可能值的抽象。例如，一个符号 x 可能代表任意整数。</span><br><span class="line">路径约束：在执行过程中，程序的控制流会根据条件分支创建不同的执行路径。符号执行会收集这些条件分支的约束，形成路径约束。</span><br></pre></td></tr></table></figure><p>执行过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始化：符号执行开始时，程序输入（如函数参数、全局变量等）被赋予符号值。</span><br><span class="line">执行：程序按照正常流程执行，但所有操作都是对符号值进行的。</span><br><span class="line">路径探索：在遇到条件分支时，符号执行会探索所有可能的路径。对于每个分支，它都会假设条件为真和假，并分别记录下相应的路径约束。</span><br><span class="line">约束求解：符号执行完成后，分析人员可以对这些路径约束进行求解，以找到满足特定路径的具体输入值。</span><br></pre></td></tr></table></figure><h4 id="例题讲解："><a href="#例题讲解：" class="headerlink" title="例题讲解："></a>例题讲解：</h4><h5 id="Ponce符号执行："><a href="#Ponce符号执行：" class="headerlink" title="Ponce符号执行："></a>Ponce符号执行：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、首先一定在输入字符串的地方打下断点，我们要在字符串开始变化之前将他定义为符号变量以记录路径约束，也方便找到我我们输入的字符串的位置，先找到scanf的那段代码，Tab查看他的汇编代码，在call _scanf 下面打下断点</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2、接着在判断的地方打一个断点，用来约束求解，去找到我们想要的值</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/2.png"><br><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3、紧接着开始调试执行程序</span><br><span class="line">4、输入字符串为了便于识别输入 123456789012345</span><br><span class="line">5、找到字符串在十六进制中的地址，并将其符号化</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/4.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6、选中31，按Ctrl + Shift + M，将其符号化，长度为15</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/5.png"><br><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7、F9执行到判断的断点哪里，然后右键选中 SMT Solver开始约束求解，结果在输出窗口那看</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/7.png"><br><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8、然后F7单步执行，会跳转到右边0x004016E6这个地址，我们在General registers窗口找到EIP将他的值改为0x004016FE 也就是跳转到左边的地址</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/9.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9、重复15次即可</span><br></pre></td></tr></table></figure><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">opcode = [0x00000004, 0x00000010, 0x00000008, 0x00000003, 0x00000005, 0x00000001, 0x00000004, 0x00000020, 0x00000008, 0x00000005, 0x00000003, 0x00000001, 0x00000003, 0x00000002, 0x00000008, 0x0000000B, 0x00000001, 0x0000000C, 0x00000008, 0x00000004, 0x00000004, 0x00000001, 0x00000005, 0x00000003, 0x00000008, 0x00000003, 0x00000021, 0x00000001, 0x0000000B, 0x00000008, 0x0000000B, 0x00000001, 0x00000004, 0x00000009, 0x00000008, 0x00000003, 0x00000020, 0x00000001, 0x00000002, 0x00000051, 0x00000008, 0x00000004, 0x00000024, 0x00000001, 0x0000000C, 0x00000008, 0x0000000B, 0x00000001, 0x00000005, 0x00000002, 0x00000008, 0x00000002, 0x00000025, 0x00000001, 0x00000002, 0x00000036, 0x00000008, 0x00000004, 0x00000041, 0x00000001, 0x00000002, 0x00000020, 0x00000008, 0x00000005, 0x00000001, 0x00000001, 0x00000005, 0x00000003, 0x00000008, 0x00000002, 0x00000025, 0x00000001, 0x00000004, 0x00000009, 0x00000008, 0x00000003, 0x00000020, 0x00000001, 0x00000002, 0x00000041, 0x00000008, 0x0000000C, 0x00000001]</span><br><span class="line">arr1 = [0x22, 0x3F, 0x34, 0x32, 0x72, 0x33, 0x18, 0x000000A7, 0x31, 0x000000F1, 0x00000028, 0x00000084, 0x000000C1, 0x0000001E, 0x0000007A]</span><br><span class="line"></span><br><span class="line">def judge(eip, cnt):</span><br><span class="line">    _eip = eip</span><br><span class="line">    for j in range(48, 123):</span><br><span class="line">        flag = j</span><br><span class="line">        while _eip &lt; 83:</span><br><span class="line">            if opcode[_eip] == 2:</span><br><span class="line">                tmp = opcode[_eip + 1] + flag</span><br><span class="line">                _eip += 2</span><br><span class="line">            elif opcode[_eip] == 3:</span><br><span class="line">                tmp = flag - opcode[_eip + 1]</span><br><span class="line">                _eip += 2</span><br><span class="line">            elif opcode[_eip] == 4:</span><br><span class="line">                tmp = opcode[_eip + 1] ^ flag</span><br><span class="line">                _eip += 2</span><br><span class="line">            elif opcode[_eip] == 5:</span><br><span class="line">                tmp = opcode[_eip + 1] * flag</span><br><span class="line">                _eip += 2</span><br><span class="line">            elif opcode[_eip] == 6:</span><br><span class="line">                _eip += 1</span><br><span class="line">            elif opcode[_eip] == 8:</span><br><span class="line">                flag = tmp</span><br><span class="line">                _eip += 1</span><br><span class="line">            elif opcode[_eip] == 11:</span><br><span class="line">                tmp = flag - 1</span><br><span class="line">                _eip += 1</span><br><span class="line">            elif opcode[_eip] == 12:</span><br><span class="line">                tmp = flag + 1</span><br><span class="line">                _eip += 1</span><br><span class="line">            elif opcode[_eip] == 1:</span><br><span class="line">                if tmp == arr1[cnt]:</span><br><span class="line">                    # print(f&quot;&#123;cnt&#125;:&#123;chr(j)&#125;&quot;)</span><br><span class="line">                    print(f&quot;&#123;chr(j)&#125;&quot;, end=&#x27;&#x27;)</span><br><span class="line">                    _eip += 1</span><br><span class="line">                    return tmp</span><br><span class="line">                else:</span><br><span class="line">                    _eip = eip</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    bb = [0, 6, 12, 17, 22, 28, 32, 38, 44, 48, 54, 60, 66, 72, 78, 83]</span><br><span class="line">    for i in range(15):</span><br><span class="line">        mid = judge(bb[i], i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> IDA </tag>
            
            <tag> Ponce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day1 IDA入门教学</title>
      <link href="/2024/10/15/%E7%AC%AC%E4%BA%94%E7%AF%87/"/>
      <url>/2024/10/15/%E7%AC%AC%E4%BA%94%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="IDA介绍与快捷键的使用"><a href="#IDA介绍与快捷键的使用" class="headerlink" title="IDA介绍与快捷键的使用"></a>IDA介绍与快捷键的使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IDA 是一款功能强大的静态反汇编工具，可以帮助安全研究人员、黑客和软件开发人员理解和分析各种编译</span><br><span class="line">后的程序文件（如EXE、DLL、ELF等）。同时也拥有动态分析功能，可以跟踪运行时的程序行为。我们新手</span><br><span class="line">先学习IDA就足够了。</span><br></pre></td></tr></table></figure><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>静态反汇编快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Shift + F12                //进入字符串窗口，所有字符串都在这</span><br><span class="line">Ctrl + X                   //可以知道那个函数引用了这个字符串</span><br><span class="line">X                          //查看函数在哪里被引用了</span><br><span class="line">G                          //将地址复制下来之后，如果想要回去，按G输入地址即可</span><br><span class="line">ALT + T                    //文本搜索</span><br><span class="line">N                          //修改函数、变量的名称</span><br><span class="line">Ctrl + Z                   //撤销操作</span><br><span class="line">/                          //添加注释</span><br><span class="line">\                          //隐藏系统自己写上的注释</span><br><span class="line">D                          //转化为数据的形式</span><br><span class="line">A                          //转化为字符类型</span><br><span class="line">C                          //转化为汇编代码形式</span><br><span class="line">U                          //转化为原始的字节模式</span><br><span class="line">Shift + E                  //导出数据</span><br><span class="line">Ctrl + E                   //找到程序的起始位置</span><br><span class="line">R                          //将常量转化为单个字符</span><br><span class="line">Ctrl + k                   //打开函数的栈，查看用到了那些变量</span><br><span class="line">ALT + M                    //添加标记</span><br><span class="line">Ctrl + M                   //查看标记，双击跳转</span><br><span class="line">ESC                        //回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口）</span><br><span class="line">Tab                        //会从反汇编代码跳转到反汇编代码</span><br><span class="line">Y                          //修改类型</span><br></pre></td></tr></table></figure><p>动态调试快捷键：<br><img src="/2024/10/15/%E7%AC%AC%E4%BA%94%E7%AF%87/1.png"></p><h3 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路"></a>做题思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、先找main函数</span><br><span class="line">2、或者通过 Shift + F12 来查看字符串，了解大概的意思找到特殊的字符串（input，correct等字样）双击</span><br><span class="line">可以到达汇编的文本代码然后通过交叉引用 Ctrl + X 来查看那些函数引用了这个代码，也可以定位到main函数</span><br><span class="line">或其他重要函数</span><br><span class="line">3、通过 F5 反汇编成我们看得懂的代码</span><br><span class="line">4、然后看到下面的(_DWORD *)这个括号里面的是注释，我们可以右键点击&quot;Hide casts&quot;隐藏起来，或者通过 \ 键</span><br></pre></td></tr></table></figure><h3 id="使用IDA"><a href="#使用IDA" class="headerlink" title="使用IDA"></a>使用IDA</h3><p><img src="/2024/10/15/%E7%AC%AC%E4%BA%94%E7%AF%87/2.png"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDA的入门使用在bilibli上有更加详细实操的教程，欢迎大家参考学习。</span><br></pre></td></tr></table></figure><h3 id="bilibili视频教程"><a href="#bilibili视频教程" class="headerlink" title="bilibili视频教程"></a>bilibili视频教程</h3><p><a href="https://www.bilibili.com/video/BV1n2tkeSEcx/?share_source=copy_web">十分钟带你快速入门CTF逆向（保姆级教程）</a></p>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse前置知识点</title>
      <link href="/2024/10/13/%E7%AC%AC%E4%B8%83%E7%AF%87/"/>
      <url>/2024/10/13/%E7%AC%AC%E4%B8%83%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="IDA逆向代码段说明"><a href="#IDA逆向代码段说明" class="headerlink" title="IDA逆向代码段说明"></a>IDA逆向代码段说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text段：text段是代码段，包含了程序的执行指令，即程序的可执行机器代码。</span><br><span class="line">.idata段：idata段是导入数据段，包含了程序需要从外部动态链接库导入的函数和变量的信息。</span><br><span class="line">.rdata段：rdata段是只读数据段，包含了程序中使用的常量数据，如字符串、静态初始化的数组等，这些数据在程序运行期间不会被修改。</span><br><span class="line">.data段：data段是数据段，包含了程序中使用的可读写数据，如全局变量和静态变量。</span><br><span class="line"></span><br><span class="line">知识点：如果一个程序的入口地址为.text段大多不带壳，因为壳会将原来的EP（入口点）给覆盖。</span><br></pre></td></tr></table></figure><h2 id="汇编知识"><a href="#汇编知识" class="headerlink" title="汇编知识"></a>汇编知识</h2><h4 id="常见数据类型："><a href="#常见数据类型：" class="headerlink" title="常见数据类型："></a>常见数据类型：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 字节型（DB，8个字节）</span><br><span class="line">- 字型（DW，16个字节）</span><br><span class="line">- 双字型（DD，32个字节）</span><br><span class="line">- 四字型（DQ，64个字节）</span><br><span class="line">- 十字节型</span><br><span class="line">- 字符串型</span><br></pre></td></tr></table></figure><h4 id="寄存器知识点以及常见汇编代码："><a href="#寄存器知识点以及常见汇编代码：" class="headerlink" title="寄存器知识点以及常见汇编代码："></a>寄存器知识点以及常见汇编代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CS:IP：任意时刻，CPU将CS:IP指向的内容当作指令执行</span><br><span class="line">DS：通常存放要访问数据的段地址</span><br><span class="line">SS:SP：任意时刻，SS:SP指向栈顶元素，SP - 2</span><br><span class="line">loop：cx中存放循环的次数</span><br><span class="line">offset：取得标号的偏移地址</span><br><span class="line"></span><br><span class="line">函数调用：</span><br><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,N</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push xxx</span><br><span class="line">ret</span><br><span class="line">就相当于</span><br><span class="line">jmp xxx </span><br></pre></td></tr></table></figure><h4 id="常用的宏："><a href="#常用的宏：" class="headerlink" title="常用的宏："></a>常用的宏：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOWORD：取32位数的低16位  </span><br><span class="line">HIWORD：取32位数的高16位  </span><br><span class="line">LOBYTE：取16位数的低8位  </span><br><span class="line">HIBYTE：去16位数的高8位  </span><br></pre></td></tr></table></figure><h4 id="函数通过参数输入："><a href="#函数通过参数输入：" class="headerlink" title="函数通过参数输入："></a>函数通过参数输入：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在C语言中，main 函数是程序执行的入口点。int __cdecl main(int argc, const char **argv, const char **envp) 中的参数具有以下含义：</span><br><span class="line"></span><br><span class="line">int argc：这是 “argument count” 的缩写，代表传递给程序的命令行参数的数量。这包括程序名称本身，因此如果有一个命令行参数，argc 将是2。</span><br><span class="line"></span><br><span class="line">const char **argv：这是 “argument vector” 的缩写，代表一个指向字符串的指针数组，这些字符串包含了传递给程序的命令行参数。argv[0] 通常包含程序的名称或者一个指向程序名称的指针，argv[1] 是第一个命令行参数，依此类推。</span><br><span class="line"></span><br><span class="line">const char **envp：这是一个指向环境变量的指针数组。每个元素都是一个以 null 结尾的字符串，形式为 “变量=值”，表示程序的环境设置。例如，envp 可能包含像 PATH=/usr/bin 或 HOME=/home/user 这样的字符串。</span><br></pre></td></tr></table></figure><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更多逆向知识，在bilibili上有视频教程，欢迎大家参考学习。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Reverse_Preview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用简单的方法解决phpstudy中的mysql与本地mysql冲突问题</title>
      <link href="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/"/>
      <url>/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a><strong>前置知识：</strong></h2><p>我们首先要知道phpstudy中的mysql与本地的mysql有哪些冲突，首先是端口都是3306冲突了，其次可能是服务名相同导致了冲突。</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h3><p>只改变服务名程，但是两者不能同时启动</p><p>1、win + s，搜索Mysql Installer -community并点击进入</p><p><img src="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/1.png"></p><p>2、点击Reconifgure，进入后一直点击next并输入密码验证，直到到了Widows Service这个选项，将服务的名称修改为不是MySQL就行。例如：MySQL8.</p><p><img src="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/2.png"></p><p>3、然后next，点击finsh即可。</p><p>4、win + r，输入services.msc，找到MySQL8，右键点击属性，叫启动类型修改为手动。</p><p>5、win + r，输入cmd，点击Ctrl + shift + 回车，进入管理员命令界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start MySQL8        //启动本地MySQL服务</span><br><span class="line">net stop MySQL8         //关闭本地MySQL服务</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a><strong>方法二：</strong></h3><p>改变phpstudy的端口为3307，且改变本地mysql的服务名。</p><p>1、按照第一部方法，修改本地mysql的服务名。</p><p>2、打开phpstudy，修改端口</p><p><img src="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/3.png"></p><p><img src="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/4.png"></p><p>3、即可两个mysql同时启动了</p><p><img src="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/5.png"></p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> phpstudy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vmware中Linux虚拟机如何扩容</title>
      <link href="/2024/10/13/linux/"/>
      <url>/2024/10/13/linux/</url>
      
        <content type="html"><![CDATA[<h2 id="理解挂载点和分区的关系"><a href="#理解挂载点和分区的关系" class="headerlink" title="理解挂载点和分区的关系"></a>理解挂载点和分区的关系</h2><p>在 Linux 系统中，挂载点（Mount Point）与分区（Partition）是文件系统管理中的两个核心概念，它们之间的关系如下：</p><ol><li><p><strong>分区</strong>：</p><ul><li>分区是指硬盘驱动器上的连续空间，它被划分为独立的区域，每个区域可以用来存储数据。</li><li>分区可以是主分区或扩展分区，扩展分区可以进一步划分为逻辑分区。</li><li>分区通常使用文件系统类型，如 ext4、NTFS、FAT32 等，这些文件系统决定了数据如何在分区上被组织和访问。</li></ul></li><li><p><strong>挂载点</strong>：</p><ul><li>挂载点是文件系统中的一个目录，它是已存在的一个空目录，用来作为分区或其他存储设备（如 USB 闪存驱动器、光盘等）与 Linux 文件系统树的连接点。</li><li>当一个分区被挂载到一个挂载点时，分区上的文件和目录就可以通过挂载点来访问。</li><li>在 Linux 系统中，挂载点可以是任何目录，但通常会在 <code>/mnt</code>、<code>/media</code> 或 <code>/var</code> 等目录下为不同的存储设备创建特定的挂载点。</li></ul></li></ol><p>简单来说：</p><p>例如，一个常见的 Linux 系统分区布局可能包括：</p><ul><li><code>/dev/sda1</code>：根分区（<code>/</code>），挂载到根目录 <code>/</code></li><li><code>/dev/sda2</code>：交换分区（swap），不被直接挂载，而是用于虚拟内存</li><li><code>/dev/sda3</code>：家目录分区（<code>/home</code>），挂载到 <code>/home</code></li><li><code>/dev/sda4</code>：数据分区（<code>/data</code>），挂载到 <code>/data</code></li></ul><h2 id="以Centos举例"><a href="#以Centos举例" class="headerlink" title="以Centos举例"></a>以Centos举例</h2><p>首先确保你的虚拟机，没有快照如果有快照是不能进行扩容的，需要将快照删除掉。</p><p><img src="/2024/10/13/linux/1.png"><br>先给虚拟机分配存储空间，这一步并不意味这你扩容成功了，还需要挂载到目录下，可以理解是windows中的未分配存储空间。</p><p><img src="/2024/10/13/linux/2.png"></p><h3 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h3><p>利用gparted命令，查看存储空间的情况（没有的话执行sudo apt install gparted<br>安装以下，这是一个图形化的工具）</p><p><img src="/2024/10/13/linux/3.png"></p><p>可以看到&#x2F;dev&#x2F;sda就是我们总的存储空间一共有51GB，跟我们设置的一样，但是还不能使用。（每个人的图可能都不样，但是原理是一样的，把中间的全部删除，合并到未分配），&#x2F;dev&#x2F;sda2挂载到了&#x2F;根目录下，大小为48.41GB。&#x2F;dev&#x2F;sda3是linux的交换区，如果没有的话开机会很慢。至于大小可以给1GB（如果存储空间很多的话）或500MB以上。</p><h3 id="进行分配"><a href="#进行分配" class="headerlink" title="进行分配"></a>进行分配</h3><p>那么先要做的就是将未分配的存储添加到&#x2F;dev&#x2F;sda2中但是它们之间隔了交换区那么就根windows一样要想合并那么就必须是两个相邻的盘，才能合并到一块。</p><p>1、右键交换区，选择停用交换空间</p><p>2、右键交换区，选择删除</p><p><img src="/2024/10/13/linux/4.png"></p><p>3、原本的交换区就会合并到未分配区。</p><p>4、右键红色1位置，选择更换大小，就可以将&#x2F;dev&#x2F;sda2进行扩容了，可以输入数据改变大小，或者拉动上面的条条左右移动，向右移扩容，确定好后点击调整大小即可。</p><p><img src="/2024/10/13/linux/5.png"></p><p>5、点击对勾，执行操作。</p><p><img src="/2024/10/13/linux/6.png"></p><p>6、如果你的分区和我不一样，我们还要确保&#x2F;etc&#x2F;fstab文件内容中，每个分区的UUID是正确的。</p><p>什么是&#x2F;etc&#x2F;fstab文件？什么是UUID？</p><p>在 Linux 系统中，<code>/etc/fstab</code>（文件系统表）是一个重要的配置文件，它列出了系统启动时应该自动挂载的文件系统。UUID（Universally Unique Identifier，通用唯一识别码）是一个用于标识信息的 128 位数字，简单来说就是每个分区唯一的标识。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> blkid              //查看真实UUID</span><br><span class="line"></span><br><span class="line">vim /etc/fstab          //修改配置文件，将UUID设置正确</span><br></pre></td></tr></table></figure><p>可以看到我们挂载到&#x2F;根目录和&#x2F;boot的UUID，是没问题的，我这里还有一个swap，后面会配置，只要修改它的UUID即可。现在先不用管，主要看你扩容的分区对应的UUID是不是正确的。</p><p><img src="/2024/10/13/linux/7.png"></p><p>这样就完成了扩容，但是如果不配置交换区的话，开机会很慢（当然还有别的不好）。</p><h3 id="配置交换区"><a href="#配置交换区" class="headerlink" title="配置交换区"></a>配置交换区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 先利用fdisk /dev/sda                  //使用 `fdisk` 命令打开磁盘 `/dev/sda`</span><br><span class="line">- 创建一个新分区sda3                   //一直回车即可</span><br><span class="line">- 将新创建的分区类型设置为 Linux Swap。按下 `t` 键，选择新创建的分区，然后输入对应的类型代码 `82`</span><br><span class="line">- 将分区标记为交换分区。按下 `p` 键查看分区表，记下你所创建的分区名称（例如 `/dev/sda2`），之后按下 `w` 键保存更改并退出 `fdisk`</span><br><span class="line">- 然后开始设置交换分区，  输入命令`mkswap /dev/sda2`</span><br></pre></td></tr></table></figure><p>1、先利用fdisk &#x2F;dev&#x2F;sda                  &#x2F;&#x2F;使用 fdisk 命令打开磁盘 &#x2F;dev&#x2F;sda</p><p><img src="/2024/10/13/linux/8.png"></p><p>2、新建分区sda3</p><p><img src="/2024/10/13/linux/9.png"></p><p>        输入 <code>p</code> 命令将显示当前磁盘的分区信息</p><p>        n命令新建分区</p><p>        选择p创建一个主分区</p><p>        之后一直回车就好（默认剩余空间全部用来当作交换区）</p><p>3、将新建的分区</p><p><img src="/2024/10/13/linux/10.png"></p><p>        命令t为分区设置system id（区分作用的）。</p><p>        选择3，也就是新建准备作为交换区的分区。</p><p>        82是分区类型代码 <code>82</code> 代表交换分区（Linux Swap）。</p><p>        w命令保存。</p><p>4、配置UUID。</p><p><img src="/2024/10/13/linux/11.png"></p><p>        mkswap &#x2F;dev&#x2F;sda3                                     &#x2F;&#x2F;设置交换分区，设置UUID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/fstab                    //修改配置文件</span><br></pre></td></tr></table></figure><p>        这里只修改了第三个swap，如果发现sudo blkid显示出来的UUID和文件里的不一样，那可能是你之前配置有误，修改文件中UUID即可。</p><p><img src="/2024/10/13/linux/12.png"></p><p>        这样就配置好了，当然弄懂上面的原理也可将，新建分区挂载到不同的目录下也行，比如一个新建目录的&#x2F;download，那么你的分区&#x2F;dev&#x2F;sda4（不一定是4，看你新建的是哪个分区）多大，你的&#x2F;download就能放多大的文件。</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vmware </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2子系统如何设置桥接和静态ip</title>
      <link href="/2024/10/13/wsl/"/>
      <url>/2024/10/13/wsl/</url>
      
        <content type="html"><![CDATA[<h2 id="利用Hyper-V创建一个虚拟交换机"><a href="#利用Hyper-V创建一个虚拟交换机" class="headerlink" title="利用Hyper-V创建一个虚拟交换机"></a>利用Hyper-V创建一个虚拟交换机</h2><p>点击 win + s，搜索Hyper-V管理器，点击进去。</p><p><img src="/2024/10/13/wsl/1.png"><br>点击“虚拟交换机管理器”。</p><p><img src="/2024/10/13/wsl/2.png"><br>类型选择“外部”，点击创建虚拟交换机。</p><p><img src="/2024/10/13/wsl/3.png"><br>输入名称，和你所用的网卡，配置完成后，点击应用、确定。</p><p><img src="/2024/10/13/wsl/4.png">​<br>（1）第一次创建，遇到创建不了的问题</p><p><img src="/2024/10/13/wsl/5.png"><br>解决方法<br>首先找到控制面板 -&gt; 查看网络状态和任务 -&gt; 更改适配器设置 -&gt; 找到WLAN（如果不是连接的WIFI，以太网也一样）-&gt; 找到共享选项全部关闭（把勾取消掉）</p><p><img src="/2024/10/13/wsl/6.png"><br>（2）之前有过现在删除重新创建<br><img src="/2024/10/13/wsl/7.png"><br>解决方法<br>win + r 输入control，进入控制面板 -&gt; 查看网络状态和任务 -&gt; 更改适配器设置 -&gt; 找到WLAN（如果不是连接的WIFI，以太网也一样）-&gt; 将Hyper-V可拓展的虚拟机交换机给取消。<br><img src="/2024/10/13/wsl/8.png"></p><h2 id="wslconfig配置文件"><a href="#wslconfig配置文件" class="headerlink" title=".wslconfig配置文件"></a>.wslconfig配置文件</h2><p><code>.wslconfig</code> 是一个用于配置 Windows Subsystem for Linux (WSL) 的配置文件。<code>.wslconfig</code> 文件提供了对 WSL 2 的全局配置选项。这个文件在%Userprofile%（C:\用户\用户名）目录下，如果没有就创建一个。<br>配置信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; 这是 WSL 2 的配置文件</span><br><span class="line"></span><br><span class="line">[wsl2]</span><br><span class="line">processors=4                            ; 设置 WSL 2 可以使用的最大 CPU 核心数为 4，自行修改</span><br><span class="line">memory=4GB                              ; 设置 WSL 2 可以使用的最大内存量为 4 GB，自行修改</span><br><span class="line">swap=4GB                                ; 设置 WSL 2 的交换空间大小为 4 GB，自行修改</span><br><span class="line">localhostForwarding=<span class="literal">true</span>                ; 允许本地主机转发</span><br><span class="line">networkingMode=bridged                  ; 设置网络模式为桥接模式</span><br><span class="line">vmSwitch=WSL                            ; 指定使用的虚拟交换机为 <span class="string">&quot;WSL&quot;</span>，这里填虚拟交换机的名称</span><br><span class="line">ipv6=<span class="literal">true</span>                               ; 启用 IPv6 支持</span><br><span class="line">dhcp=<span class="literal">false</span>                              ; 禁用 DHCP，手动设置网络配置</span><br><span class="line"></span><br><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual               ; 慢慢回收内存</span><br><span class="line">autoProxy=<span class="literal">true</span>                          ; 启用自动代理设置</span><br></pre></td></tr></table></figure><h2 id="etc-netplan目录下生成-yaml文件"><a href="#etc-netplan目录下生成-yaml文件" class="headerlink" title="&#x2F;etc&#x2F;netplan目录下生成*.yaml文件"></a>&#x2F;etc&#x2F;netplan目录下生成*.yaml文件</h2><p>完成以上两步（虽然已经是桥接模式但是WSL2子系统的ip不是固定的，而且可能会与宿主主机的ip相同，那么你在子系统开启的服务，例如：8989端口开启了http服务，那么你在主机是访问不到这个服务的），所以我们还要进一步配置。</p><p>在 Linux 系统中，<code>/etc/netplan</code> 目录下的 <code>.yaml</code> 文件是用于配置网络设置的。</p><p>首先进入，Linux子系统中，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@LAPTOP-GUB0QBS8:/# <span class="built_in">cd</span> /etc/netplan</span><br><span class="line">root@LAPTOP-GUB0QBS8:/etc/netplan# <span class="built_in">ls</span></span><br><span class="line">zwy.yaml                                                 //这里之前已经创建过了</span><br><span class="line">root@LAPTOP-GUB0QBS8:/etc/netplan# <span class="built_in">touch</span> xxx.yaml</span><br><span class="line">root@LAPTOP-GUB0QBS8:/etc/netplan# <span class="built_in">ls</span></span><br><span class="line">xxx.yaml  zwy.yaml</span><br><span class="line">root@LAPTOP-GUB0QBS8:/etc/netplan# nano xxx.yaml         //进行编辑</span><br></pre></td></tr></table></figure><p>编辑内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  ethernets:</span><br><span class="line">    eth0:</span><br><span class="line">      dhcp4: no</span><br><span class="line">      addresses:</span><br><span class="line">        - 192.168.1.223/24   <span class="comment"># 设置一个不与主机相同的IP地址</span></span><br><span class="line">      gateway4: 192.168.1.1  <span class="comment"># 设置网关地址</span></span><br><span class="line">      nameservers:           <span class="comment">#dns服务，这下面可以跟我一样</span></span><br><span class="line">          addresses:</span><br><span class="line">              - 8.8.8.8</span><br><span class="line">              - 8.8.4.4</span><br><span class="line">              - 223.5.5.5  <span class="comment"># 添加中国移动公共DNS服务器地址</span></span><br><span class="line">              - 223.6.6.6  <span class="comment"># 添加中国移动公共DNS服务器地址</span></span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>查看，Linux子系统的ip（这样就配置完成了），且如果用Vmware创建的虚拟机是桥接模式，它们之间是可以相互ping通的。<br><img src="/2024/10/13/wsl/9.png"></p><p>这里还用关于WSL一些操作的笔记，可以下来看看，用的Xmind这款软件做的笔记。<br><a href="https://www.123pan.com/s/WK4vTd-dapn.html" title="https://www.123pan.com/s/WK4vTd-dapn.html">https://www.123pan.com/s/WK4vTd-dapn.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL2 </tag>
            
            <tag> Hyper-V </tag>
            
            <tag> 静态ip </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
