<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的第一个Github项目-Bilibili_fetcher</title>
      <link href="/2024/11/16/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AF%87/"/>
      <url>/2024/11/16/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="Bilibili-fetcher"><a href="#Bilibili-fetcher" class="headerlink" title="Bilibili_fetcher"></a>Bilibili_fetcher</h4><p>B站资源免费获取、提供在线播放音乐、本地播放音乐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">搜索功能：输入关键词，右方窗口会出现搜索结果，双击可以将其复制到视频链接中。</span><br><span class="line"></span><br><span class="line">视频链接：可以自己输入也可以通过双击右边搜索结果，将其复制到视频链接中。</span><br><span class="line"></span><br><span class="line">Cookie：输入一次后会保存在./Cookie/Cookie.txt文件中，下次打开软件时会自动读取。</span><br><span class="line">        如果文件中有未过期的Cookie，就会自动添加不用输入，有的话输入框会显示灰色</span><br><span class="line">        如果文件中没有Cookie，则需要输入（会有提醒）。没有Cookie的情况下下载的</span><br><span class="line">        视频只能是360P，反之就是 1080P。</span><br><span class="line">        </span><br><span class="line">保存路径：可以指定输出路径，默认在当前目录下的相应子目录。</span><br><span class="line"></span><br><span class="line">三个选择框：可以选择下载视频、音频（默认）、图片。</span><br><span class="line"></span><br><span class="line">下载：点击后会开始下载，下载完成后会弹出提示。</span><br><span class="line"></span><br><span class="line">在线播放：点击可以在线播放当前连接音乐，有些音频并不支持。</span><br><span class="line"></span><br><span class="line">本地播放：点击后选择MP3文件所在目录，然后就会显示该目录下的所有mp3文件（根据</span><br><span class="line">此可以创建不同的文件夹放不同类型的歌曲也就是不同的歌单，），可以双击一首开</span><br><span class="line">始播放，有循环和顺序播放两种默认模式是顺序播放。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="功能展示"><a href="#功能展示" class="headerlink" title="功能展示"></a>功能展示</h4><p>主界面<br><img src="/2024/11/16/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AF%87/1.png"><br>本地播放<br><img src="/2024/11/16/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AF%87/2.png"><br>在线播放<br><img src="/2024/11/16/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AF%87/3.png"></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bilibili_fetcher </tag>
            
            <tag> python爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯2024 revers1（four）</title>
      <link href="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87/"/>
      <url>/2024/11/10/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="网鼎杯2024-revers1（four）"><a href="#网鼎杯2024-revers1（four）" class="headerlink" title="网鼎杯2024 revers1（four）"></a>网鼎杯2024 revers1（four）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将 four 文件拖进 Exeinfo 分析，64 位无壳的 elf 文件。</span><br><span class="line">打开IDA Pro进行分析进入字符串窗口，可以看到一串很base64码表的东西，但是只有63位先不管</span><br><span class="line">DEFGHIJKLMNOPQRSTUVWXYZABabcdefghijklmnopqrstuvwxyz0123456789+/，下面有 Enter the flag </span><br><span class="line">字样，双击，Ctrl + x 查看交叉引用，来到 main 函数，F5 进行反编译。</span><br></pre></td></tr></table></figure><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87/1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以看到这里要求输入字符串给变量 s，长度必须是 40，暂时 v20 看不出来是什么，他将 32 位给了dst</span><br><span class="line"></span><br><span class="line">仔细观察观察发现有四个 if 函数，如果为真则就退出，里面的条件是 cmp 比较每次比较 8 位，也就时</span><br><span class="line">将输入的字符串提取出 wdflag&#123;xxxxx&#125;,xxxxx 一共 32 位给了dst变量，分为四段，分别进行一些操作然</span><br><span class="line">后和字符串进行比较，如果相等就返回 0 继续向下，反之就退出。分别在四个if前面加上断点通过动态调</span><br><span class="line">试找到加密后的字符串进行解密。配置远程调试。监听进程（这里用到centos 7 的调试器）</span><br></pre></td></tr></table></figure><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87/2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">第一个if就是将dst的前八位乘以2，然后与s2进行比较。因为s2是程序执行后才进行赋值的，所以要动态</span><br><span class="line">调试，然后利用LazyIDA的convert将s2以python数组的形式输出出来。也可以一个个手打出来。</span><br><span class="line">s2 = [0x6A, 0xC4, 0xCC, 0x62, 0xC2, 0x6E, 0xCA, 0xCA]</span><br><span class="line"></span><br><span class="line">第二个if就是将第8~15位输入的字符串与v22数组进行异或，结果存放在v13数组中。最后v13与v11进行比较，</span><br><span class="line">这里要注意v11和v12是连续的地址，所以两个加起来刚好是8位的数组。</span><br><span class="line">v11 = [0x60, 0x58, 0x16, 0x47, 0x7D, 0x5C, 0x44, 0x5D]</span><br><span class="line"></span><br><span class="line">第三个if就是将16~23位输入的字符串进行base64加密，只不过base64加密函数自定义的，码表为 base_tables</span><br><span class="line">CDEFGHIJKLMNOPQRSTUVWXYZABabcdefghijklmnopqrstuvwxyz0123456789+/ 前面有个C，别看漏了。加密的密文</span><br><span class="line">为 BFO1AjdmPmG 可以利用 cyberchef 进行解密，也可以手搓。</span><br><span class="line"></span><br><span class="line">第四个if就是将24~31位输入的字符串用8来补满十六位，然后v9为密钥一共27个字节刚好128位，使用</span><br><span class="line">AES-128 ECB 加密算法加密，结果与 v4 数组进行比较。</span><br><span class="line">v9 = [0x41, 0x65, 0x73, 0x4D, 0x61, 0x73, 0x74, 0x65, 0x72, 0x41, 0x65, 0x73, 0x4D, 0x61, 0x73, 0x74, 0x42, 0x46, 0x4F, 0x31, 0x41, 0x6A, 0x64, 0x6D, 0x50, 0x6D, 0x47]</span><br><span class="line">v4 = [0x0F, 0xE3, 0x2F, 0xE6, 0x58, 0x20, 0x9B, 0x3A, 0xD6, 0xE4, 0x18, 0x3F, 0xA7, 0x78, 0xA5, 0x82]</span><br></pre></td></tr></table></figure><p>完整解密脚本为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">flag = <span class="string">&#x27;wdflag&#123;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一部分</span></span><br><span class="line">s2 = [<span class="number">0x6A</span>, <span class="number">0xC4</span>, <span class="number">0xCC</span>, <span class="number">0x62</span>, <span class="number">0xC2</span>, <span class="number">0x6E</span>, <span class="number">0xCA</span>, <span class="number">0xCA</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s2:</span><br><span class="line">flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(i/<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 第二部分</span></span><br><span class="line">v11 = [<span class="number">0x60</span>, <span class="number">0x58</span>, <span class="number">0x16</span>, <span class="number">0x47</span>, <span class="number">0x7D</span>, <span class="number">0x5C</span>, <span class="number">0x44</span>, <span class="number">0x5D</span>]</span><br><span class="line">v22 = [<span class="number">0x58</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x72</span>, <span class="number">0x4c</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x64</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    flag += <span class="built_in">chr</span>(v11[i] ^ v22[i])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 第三部分</span></span><br><span class="line">base_tables = <span class="string">&#x27;CDEFGHIJKLMNOPQRSTUVWXYZABabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line"><span class="comment"># 加密字符串</span></span><br><span class="line">m = <span class="string">&#x27;BFO1AjdmPmG&#x27;</span></span><br><span class="line"><span class="comment"># 利用cyberchef进行解密</span></span><br><span class="line">flag += <span class="string">&#x27;d35b7f6a&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将密文和密钥从十六进制格式转换为字节</span></span><br><span class="line">ss = <span class="built_in">bytes</span>([<span class="number">0x0F</span>, <span class="number">0xE3</span>, <span class="number">0x2F</span>, <span class="number">0xE6</span>, <span class="number">0x58</span>, <span class="number">0x20</span>, <span class="number">0x9B</span>, <span class="number">0x3A</span>, <span class="number">0xD6</span>, <span class="number">0xE4</span>, <span class="number">0x18</span>, <span class="number">0x3F</span>, <span class="number">0xA7</span>, <span class="number">0x78</span>,<span class="number">0xA5</span>, <span class="number">0x82</span>])</span><br><span class="line">key_128 = <span class="built_in">bytes</span>([<span class="number">0x41</span>, <span class="number">0x65</span>, <span class="number">0x73</span>, <span class="number">0x4D</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x41</span>, <span class="number">0x65</span>, <span class="number">0x73</span>, <span class="number">0x4D</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x74</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 AES-128 ECB 模式解密</span></span><br><span class="line">cipher = AES.new(key_128, AES.MODE_ECB)</span><br><span class="line">decrypted = cipher.decrypt(ss)</span><br><span class="line"><span class="comment"># 输出解密后的结果</span></span><br><span class="line">flag += <span class="built_in">str</span>(decrypted[:<span class="number">8</span>]).replace(<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">flag += <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网鼎杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day5 网鼎杯2020jocker SMC与堆栈平衡</title>
      <link href="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/"/>
      <url>/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="SMC技术"><a href="#SMC技术" class="headerlink" title="SMC技术"></a>SMC技术</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SMC，即Self Modifying Code，动态代码加密技术，指通过修改代码或数据，阻止别人直接静态分析，然</span><br><span class="line">后在动态运行程序时对代码进行解密，达到程序正常运行的效果。</span><br><span class="line"></span><br><span class="line">VirtualProtect 函数通常用于代码自加密的场景。代码自加密是一种保护代码不被轻易逆向分析的技术，</span><br><span class="line">通过在程序运行时动态地修改代码的内存保护属性，使得代码在执行时可以被修改和执行，但在不执行时则</span><br><span class="line">不能被读取或修改。</span><br><span class="line"></span><br><span class="line">在linux系统中，可以通过mprotect函数修改目标内存的权限</span><br><span class="line">在Windows系统中，VirtualProtect函数实现内存权限的修改</span><br><span class="line">因此也可以观察是否有这俩个函数来判断是否进行了SMC</span><br><span class="line"></span><br><span class="line">SMC一般有俩种破解方法，第一种是找到对代码或数据加密的函数后通过idapython写解密脚本。第二种是动</span><br><span class="line">态调试到SMC解密结束的地方dump出来。</span><br></pre></td></tr></table></figure><h4 id="堆栈平衡"><a href="#堆栈平衡" class="headerlink" title="堆栈平衡"></a>堆栈平衡</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆栈不平衡问题出现原因</span></span><br><span class="line">  one：一般是程序代码有一些干扰代码，让IDA的反汇编分析出现错误。比如用push + n条指令 + retn来</span><br><span class="line">实际跳转，而IDA会以为retn是函数要结束，结果它分析后发现调用栈不平衡，因此就提示sp analysis failed.</span><br><span class="line">  two：还有一些比如编译器优化，因为ida是用retn指令来识别函数结束的，如果函数不是以这种方式结束，</span><br><span class="line">IDA就会分析为栈不平衡。也就是IDA找不到函数结束的位置。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆栈平衡原理</span></span><br><span class="line"><span class="number">1</span>、概念解释</span><br><span class="line">  函数返回时，堆栈需要恢复到调用前的状态</span><br><span class="line"><span class="number">2</span>、平衡的重要性</span><br><span class="line">  避免内存访问错误和程序崩溃</span><br><span class="line">  保证程序的正常执行逻辑</span><br><span class="line"><span class="number">3</span>、平栈的方式</span><br><span class="line">  外平栈（cdecl）</span><br><span class="line">    在 cdecl 调用约定中，参数也是从右往左一次压入堆栈，但堆栈平衡由调用者在函数返回后负责清理</span><br><span class="line">  内平栈（stdcall）</span><br><span class="line">    stdcall 是内平栈，既有被调用函数在返回前负责清理堆栈，通过调整栈指针来移除压入栈中的参数</span><br></pre></td></tr></table></figure><h4 id="下面简单举个例子，让大家更深刻的了解堆栈平衡的概念"><a href="#下面简单举个例子，让大家更深刻的了解堆栈平衡的概念" class="headerlink" title="下面简单举个例子，让大家更深刻的了解堆栈平衡的概念"></a>下面简单举个例子，让大家更深刻的了解堆栈平衡的概念</h4><p><a href="https://www.bilibili.com/video/BV1Xt411x7Dr/?share_source=copy_web&vd_source=cb1799ab55ca5d1f2c72c3c2c11d5e74">汇编中的函数调用中栈的工作过程</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面以汇编的角度来解释函数调用的过程，这里就以上面视频中的例子为例</span></span><br><span class="line">  A_Func(<span class="number">5</span>,<span class="number">6</span>); <span class="comment">// 这里main函数要调用A_Func函数，参数为5和6，此时假设esp的值为0x1000</span></span><br><span class="line">  push <span class="number">6</span> <span class="comment">// 参数先入栈，顺序为从右往左</span></span><br><span class="line">  push <span class="number">5</span> <span class="comment">// 此时 esp 因为加入了了两个int类型参数，所以变成了0x1000-8</span></span><br><span class="line">  call A_Func <span class="comment">// call指令做的操作相当于把当前的eip值压入栈中（也就是call指令的下一条指令地址），并跳转到A_Func函的入口地址</span></span><br><span class="line">  add esp, <span class="number">8</span> <span class="comment">// 这一步做的就是平栈操作，把刚才压入栈中的参数弹出，恢复esp的原值，此时esp的值为0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上就是堆栈平衡的过程，简单来说就是调用函数前后堆栈的状态要保持一致。</span></span><br><span class="line"><span class="comment">// 在调用函数时，会先将参数从右到左依次压入栈中，然后 call 跳转到被调用函数（压入call指令的</span></span><br><span class="line"><span class="comment">//下一个指令的地址），在被调用函数中在进行 push ebp; 等操作。我们可以 F9 步过call指令，会发</span></span><br><span class="line"><span class="comment">// 现 ESP又恢复了参数压入之前的数值，这就是堆栈平衡。</span></span><br></pre></td></tr></table></figure><h4 id="网鼎杯2020jocker"><a href="#网鼎杯2020jocker" class="headerlink" title="网鼎杯2020jocker"></a>网鼎杯2020jocker</h4><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/1.png"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用Exeinfo查看文件的PE信息，可以知道文件是 32为无壳程序，利用IDA Pro打开</span></span><br><span class="line">Shift+F12 进入字符串窗口 -&gt; 看到关键字<span class="string">&quot;please input you flag:&quot;</span>，双击进入 -&gt; Ctrl+x查看交叉引用 -&gt; 从而定位到main函数</span><br><span class="line"><span class="comment">// 利用IDA打开，出现 positive sp value has been detected, the output may be wrong!</span></span><br><span class="line"><span class="comment">// 出现了栈不平衡的问题，导致ida无法生成代码。</span></span><br><span class="line">选项 -&gt; 常规 -&gt; 堆栈指针（查看栈帧变换）</span><br></pre></td></tr></table></figure><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/5.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  可以看到，箭头指的两个地方栈偏移都出了问题，应该在call完之后都会平栈，也就是应该都是0AC才对，</span><br><span class="line">我们有快捷键 alt+k 将偏移改为<span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后F5返回main函数可以发现报错没了</span><br></pre></td></tr></table></figure><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/2.png"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">先简单分析代码，可以知道输入字符串长度为<span class="number">24</span>，这里还有 VirtualProtect 函数，可以猜测用到了SMC技术，</span><br><span class="line">加密了encrypt()函数，并在倒数第<span class="number">6</span>行动态解密encrypt()函数。中间还有一个将输入的Str字符串赋值给了</span><br><span class="line">Destination变量。</span><br><span class="line">然后就是，Str经过wrong()函数和omg()函数，接下来我们进入看看，具体做了那些操作。</span><br></pre></td></tr></table></figure><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/3.png"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  首先，wrong()函数的主要操作就是，遍历输入的Str字符串，若下标i为奇数，该元素就与下标做减法。相反</span><br><span class="line">若是偶数，则该元素与下标做异或。</span><br><span class="line">  最后omg()函数就是比较，经过处理后的Str字符串与&amp;unk_4030c0的字符串进行比较，若相同则输入正确，反</span><br><span class="line">之错误。</span><br><span class="line">  但是得出来的flag是错误的，真正的加密在encrypt()函数中，我们需要找到这个函数。但是encrypt()函数</span><br><span class="line">由于堆栈不平衡反汇编不出来，且是用到SMC技术的，所以我们这里用动态调试的方式来解决这些问题。</span><br></pre></td></tr></table></figure><h5 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h5><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/4.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根据上图下好断点后，进入动态调试之后，随便输入24位字符串aaaaaaaaaaaaaaaaaaaaaaaa。</span><br><span class="line">点击上方的视图 -&gt; 选择反汇编窗口 -&gt; 然后按 F7 单步执行进入encrypt()函数。可以看到红线下面还有一段</span><br><span class="line">代码它不属于任何函数中，应该就是ida识别错误。</span><br></pre></td></tr></table></figure><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击__Z7encryptPc 先用U将其设为无定义</span><br></pre></td></tr></table></figure><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/9.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">再按 c 声明为代码段（对黄色线条之内的数据），点击 F(强制) + yes，最后返回点击__Z7encryptPc 用 P 将</span><br><span class="line">其设置为函数，然后 F5 / Tab 键来到反汇编界面，encrypted函数就被修复了，最后就是<span class="keyword">finally</span>函数，直接对</span><br><span class="line">loc_40159A按 P 即可</span><br><span class="line"></span><br><span class="line"><span class="comment">//sub_40159A：</span></span><br><span class="line">含义：sub_40159A 通常表示一个完整的函数（subroutine），位于地址 <span class="number">0x40159A</span>。</span><br><span class="line">命名习惯：sub_ 前缀加上地址的形式通常用于自动命名 IDA 识别的函数。例如 sub_40159A 表示 IDA 认为从 </span><br><span class="line"><span class="number">0x40159A</span> 地址开始是一段独立的代码，符合函数的结构。</span><br><span class="line"></span><br><span class="line"><span class="comment">//loc_40159A：</span></span><br><span class="line">含义：loc_40159A 表示一个代码标签（location），通常用于跳转或引用的位置，位于地址 <span class="number">0x40159A</span>。</span><br><span class="line">命名习惯：loc_ 前缀加上地址表示 IDA 识别的某个特定位置，作为代码段内的标签或局部跳转目标。</span><br></pre></td></tr></table></figure><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/10.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">完成以上步骤，encrypt()函数和finally()函数就被修复了。函数代码如下：</span><br></pre></td></tr></table></figure><p><img src="/2024/11/10/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87/11.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">encrypt()函数：</span><br><span class="line">可以看到就是将输入字符串的前<span class="number">19</span>位与Buffer数组进行一对一异或，异或后的结果与v2数组一对一比较。</span><br><span class="line">也就是说v2数组就是加密后的前<span class="number">19</span>位字符串。</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>()函数：</span><br><span class="line">不知道他在干嘛，但是根据网上资料知道，输入字符串后面<span class="number">5</span>位应该是与某一个随机数进行异或得到v3。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密脚本</span></span><br><span class="line">hh = <span class="string">&#x27;hahahaha_do_you_find_me?&#x27;</span></span><br><span class="line">v2 = [<span class="number">0x0E</span>, <span class="number">0x0D</span>, <span class="number">0x9</span>, <span class="number">0x6</span>, <span class="number">0x13</span>, <span class="number">0x5</span>, <span class="number">0x58</span>, <span class="number">0x56</span>, <span class="number">0x3E</span>, <span class="number">0x6</span>,<span class="number">0x0C</span>, <span class="number">0x3C</span>, <span class="number">0x1F</span>, <span class="number">0x57</span>, <span class="number">0x14</span>, <span class="number">0x6B</span>, <span class="number">0x57</span>, <span class="number">0x59</span>, <span class="number">0x0D</span>]</span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">    flag.append(<span class="built_in">chr</span>(v2[i] ^ <span class="built_in">ord</span>(hh[i])))</span><br><span class="line"></span><br><span class="line">v3 = [<span class="number">37</span>, <span class="number">116</span>, <span class="number">112</span>, <span class="number">38</span>, <span class="number">58</span>]</span><br><span class="line">key = <span class="built_in">ord</span>(<span class="string">&#x27;&#125;&#x27;</span>) ^ <span class="number">58</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    flag.append(<span class="built_in">chr</span>(v3[i] ^ key))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))</span><br><span class="line"><span class="comment"># flag&#123;d07abccf8a410cb37a&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网鼎杯 </tag>
            
            <tag> SMC </tag>
            
            <tag> 堆栈平衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day4 pyinstaller解包方法（羊城杯login）</title>
      <link href="/2024/10/27/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87/"/>
      <url>/2024/10/27/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.123pan.com/s/WK4vTd-tyMn">python_exe解压包 提取码:bbxb</a></p><h4 id="Pyinstaller介绍"><a href="#Pyinstaller介绍" class="headerlink" title="Pyinstaller介绍"></a>Pyinstaller介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PyInstaller是一个开源的Python程序打包工具，它能够将Python应用程序打包成独立的执行文件，无需</span><br><span class="line">依赖Python解释器即可在多种操作系统上运行。这对于分发Python应用程序非常有用，因为用户无需安装</span><br><span class="line">Python或应用程序所依赖的库，就可以直接运行程序。</span><br><span class="line"></span><br><span class="line">经过 PyInstaller 打包的 .exe 文件不能直接用 IDA Pro 顺利分析，因为 PyInstaller 将 Python 字</span><br><span class="line">节码和依赖打包成机器码执行文件，而 IDA Pro 主要用于分析机器码，对字节码的直接分析支持有限，且</span><br><span class="line">打包过程中可能包含的混淆和加密技术增加了分析的难度。</span><br></pre></td></tr></table></figure><h4 id="Pyinstaller解包方法（羊城杯login）"><a href="#Pyinstaller解包方法（羊城杯login）" class="headerlink" title="Pyinstaller解包方法（羊城杯login）"></a>Pyinstaller解包方法（羊城杯login）</h4><ul><li>pyc文件恢复</li><li>反编译pyc文件</li></ul><h5 id="pyc文件恢复"><a href="#pyc文件恢复" class="headerlink" title="pyc文件恢复"></a>pyc文件恢复</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在将python文件打包成exe文件的过程中，会抹去pyc文件前面的部分信息，所以在反编译之前需要检查并添</span><br><span class="line">加上这部分信息。</span><br><span class="line">抹去的信息内容可以从struct文件中获取，利用<span class="number">0</span>10editor添加这部分信息。</span><br><span class="line"></span><br><span class="line">方法一（利用pyinstxtractor.py）：</span><br><span class="line"><span class="comment"># 执行下面命令，会生成 target.exe_extracted 文件，里面会有pyc入口文件</span></span><br><span class="line">python pyinstxtractor.py target.exe</span><br><span class="line"></span><br><span class="line">方法二（archive_viewer.py）：</span><br><span class="line"><span class="comment"># 执行以下命令，会显示由 PyInstaller 打包的 .exe 文件中的内容，然后利用 x filename 命令提取文件，并命名为.pyc文件。</span></span><br><span class="line">pos：文件在 .exe 文件中的起始位置。</span><br><span class="line">length：文件在 .exe 文件中的长度（压缩后的长度）。</span><br><span class="line">uncompressed：文件解压后的原始长度。</span><br><span class="line">iscompressed：一个标志，指示文件是否被压缩。</span><br><span class="line"><span class="built_in">type</span>：文件类型。</span><br><span class="line">name：文件或模块的名称。</span><br><span class="line"></span><br><span class="line">python archive_viewer.py target.exe</span><br><span class="line"></span><br><span class="line">方法三：</span><br><span class="line">直接使用 EasyPythonDecompiler 工具，可以直接查看 .exe 文件中的内容，并提取出 .pyc 文件。</span><br></pre></td></tr></table></figure><h5 id="反编译pyc文件"><a href="#反编译pyc文件" class="headerlink" title="反编译pyc文件"></a>反编译pyc文件</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 uncompyle6 库</span></span><br><span class="line">pip install uncompyle6</span><br><span class="line"><span class="comment"># 反编译pyc文件</span></span><br><span class="line">uncompyle6 login.pyc</span><br></pre></td></tr></table></figure><h5 id="演示案例：羊城杯login"><a href="#演示案例：羊城杯login" class="headerlink" title="演示案例：羊城杯login"></a>演示案例：羊城杯login</h5><ul><li>利用 exeinfo 查看文件的PE信息</li><li>利用 pyinstxtractor.py 解包pyc文件</li><li>利用 uncompyle6 反编译pyc文件</li><li>根据反编译文件 逆向flag<br><img src="/2024/10/27/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87/1.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到，是经过pyinstaller打包的exe文件，python版本为3.6，所以先恢复pyc文件</span></span><br><span class="line"><span class="comment"># 这里用第一种方法，利用Aconada中的python3.6虚拟环境执行以下命令，由于环境正确所</span></span><br><span class="line"><span class="comment"># 以这里不需要额外去对照struct.pyc文件去修复login.pyc文件，如果没有生成login.pyc</span></span><br><span class="line"><span class="comment"># 文件，就利用 010editor 工具对比struct.pyc文件和login.pyc文件的头部信息，为login.pyc</span></span><br><span class="line"><span class="comment"># 并添加上缺少的头部信息</span></span><br><span class="line">python pyinstxtractor.py login.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来进入到生成的文件夹中，可以看到login.pyc文件，用uncompyle6反编译</span></span><br><span class="line">uncompyle6 login.pyc</span><br><span class="line"></span><br><span class="line">源码如下：</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">input1 = <span class="built_in">input</span>(<span class="string">&quot;input something:&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(input1) != <span class="number">14</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Wrong length!&quot;</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    code = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">        code.append(<span class="built_in">ord</span>(input1[i]) ^ <span class="built_in">ord</span>(input1[i + <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    code.append(<span class="built_in">ord</span>(input1[<span class="number">13</span>]))</span><br><span class="line">    a1 = code[<span class="number">2</span>]</span><br><span class="line">    a2 = code[<span class="number">1</span>]</span><br><span class="line">    a3 = code[<span class="number">0</span>]</span><br><span class="line">    a4 = code[<span class="number">3</span>]</span><br><span class="line">    a5 = code[<span class="number">4</span>]</span><br><span class="line">    a6 = code[<span class="number">5</span>]</span><br><span class="line">    a7 = code[<span class="number">6</span>]</span><br><span class="line">    a8 = code[<span class="number">7</span>]</span><br><span class="line">    a9 = code[<span class="number">9</span>]</span><br><span class="line">    a10 = code[<span class="number">8</span>]</span><br><span class="line">    a11 = code[<span class="number">10</span>]</span><br><span class="line">    a12 = code[<span class="number">11</span>]</span><br><span class="line">    a13 = code[<span class="number">12</span>]</span><br><span class="line">    a14 = code[<span class="number">13</span>]</span><br><span class="line">    <span class="keyword">if</span> (a1 * <span class="number">88</span> + a2 * <span class="number">67</span> + a3 * <span class="number">65</span> - a4 * <span class="number">5</span> + a5 * <span class="number">43</span> + a6 * <span class="number">89</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">36</span> + a10 * <span class="number">15</span> + a11 * <span class="number">11</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> + a14 * <span class="number">29</span> == <span class="number">22748</span>) &amp; (a1 * <span class="number">89</span> + a2 * <span class="number">7</span> + a3 * <span class="number">12</span> - a4 * <span class="number">25</span> + a5 * <span class="number">41</span> + a6 * <span class="number">23</span> + a7 * <span class="number">20</span> - a8 * <span class="number">66</span> + a9 * <span class="number">31</span> + a10 * <span class="number">8</span> + a11 * <span class="number">2</span> - a12 * <span class="number">41</span> - a13 * <span class="number">39</span> + a14 * <span class="number">17</span> == <span class="number">7258</span>) &amp; (a1 * <span class="number">28</span> + a2 * <span class="number">35</span> + a3 * <span class="number">16</span> - a4 * <span class="number">65</span> + a5 * <span class="number">53</span> + a6 * <span class="number">39</span> + a7 * <span class="number">27</span> + a8 * <span class="number">15</span> - a9 * <span class="number">33</span> + a10 * <span class="number">13</span> + a11 * <span class="number">101</span> + a12 * <span class="number">90</span> - a13 * <span class="number">34</span> + a14 * <span class="number">23</span> == <span class="number">26190</span>) &amp; (a1 * <span class="number">23</span> + a2 * <span class="number">34</span> + a3 * <span class="number">35</span> - a4 * <span class="number">59</span> + a5 * <span class="number">49</span> + a6 * <span class="number">81</span> + a7 * <span class="number">25</span> + (a8 &lt;&lt; <span class="number">7</span>) - a9 * <span class="number">32</span> + a10 * <span class="number">75</span> + a11 * <span class="number">81</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> + a14 * <span class="number">29</span> == <span class="number">37136</span>) &amp; (a1 * <span class="number">38</span> + a2 * <span class="number">97</span> + a3 * <span class="number">35</span> - a4 * <span class="number">52</span> + a5 * <span class="number">42</span> + a6 * <span class="number">79</span> + a7 * <span class="number">90</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span> + a10 * <span class="number">57</span> + a11 * <span class="number">81</span> + a12 * <span class="number">42</span> - a13 * <span class="number">62</span> - a14 * <span class="number">11</span> == <span class="number">27915</span>) &amp; (a1 * <span class="number">22</span> + a2 * <span class="number">27</span> + a3 * <span class="number">35</span> - a4 * <span class="number">45</span> + a5 * <span class="number">47</span> + a6 * <span class="number">49</span> + a7 * <span class="number">29</span> + a8 * <span class="number">18</span> - a9 * <span class="number">26</span> + a10 * <span class="number">35</span> + a11 * <span class="number">41</span> + a12 * <span class="number">40</span> - a13 * <span class="number">61</span> + a14 * <span class="number">28</span> == <span class="number">17298</span>) &amp; (a1 * <span class="number">12</span> + a2 * <span class="number">45</span> + a3 * <span class="number">35</span> - a4 * <span class="number">9</span> - a5 * <span class="number">42</span> + a6 * <span class="number">86</span> + a7 * <span class="number">23</span> + a8 * <span class="number">85</span> - a9 * <span class="number">47</span> + a10 * <span class="number">34</span> + a11 * <span class="number">76</span> + a12 * <span class="number">43</span> - a13 * <span class="number">44</span> + a14 * <span class="number">65</span> == <span class="number">19875</span>) &amp; (a1 * <span class="number">79</span> + a2 * <span class="number">62</span> + a3 * <span class="number">35</span> - a4 * <span class="number">85</span> + a5 * <span class="number">33</span> + a6 * <span class="number">79</span> + a7 * <span class="number">86</span> + a8 * <span class="number">14</span> - a9 * <span class="number">30</span> + a10 * <span class="number">25</span> + a11 * <span class="number">11</span> + a12 * <span class="number">57</span> - a13 * <span class="number">50</span> - a14 * <span class="number">9</span> == <span class="number">22784</span>) &amp; (a1 * <span class="number">8</span> + a2 * <span class="number">6</span> + a3 * <span class="number">64</span> - a4 * <span class="number">85</span> + a5 * <span class="number">73</span> + a6 * <span class="number">29</span> + a7 * <span class="number">2</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span> + a10 * <span class="number">5</span> + a11 * <span class="number">2</span> + a12 * <span class="number">47</span> - a13 * <span class="number">64</span> + a14 * <span class="number">27</span> == <span class="number">9710</span>) &amp; (a1 * <span class="number">67</span> - a2 * <span class="number">68</span> + a3 * <span class="number">68</span> - a4 * <span class="number">51</span> - a5 * <span class="number">43</span> + a6 * <span class="number">81</span> + a7 * <span class="number">22</span> - a8 * <span class="number">12</span> - a9 * <span class="number">38</span> + a10 * <span class="number">75</span> + a11 * <span class="number">41</span> + a12 * <span class="number">27</span> - a13 * <span class="number">52</span> + a14 * <span class="number">31</span> == <span class="number">13376</span>) &amp; (a1 * <span class="number">85</span> + a2 * <span class="number">63</span> + a3 * <span class="number">5</span> - a4 * <span class="number">51</span> + a5 * <span class="number">44</span> + a6 * <span class="number">36</span> + a7 * <span class="number">28</span> + a8 * <span class="number">15</span> - a9 * <span class="number">6</span> + a10 * <span class="number">45</span> + a11 * <span class="number">31</span> + a12 * <span class="number">7</span> - a13 * <span class="number">67</span> + a14 * <span class="number">78</span> == <span class="number">24065</span>) &amp; (a1 * <span class="number">47</span> + a2 * <span class="number">64</span> + a3 * <span class="number">66</span> - a4 * <span class="number">5</span> + a5 * <span class="number">43</span> + a6 * <span class="number">112</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">35</span> + a10 * <span class="number">95</span> + a11 * <span class="number">21</span> + a12 * <span class="number">43</span> - a13 * <span class="number">61</span> + a14 * <span class="number">20</span> == <span class="number">27687</span>) &amp; (a1 * <span class="number">89</span> + a2 * <span class="number">67</span> + a3 * <span class="number">85</span> - a4 * <span class="number">25</span> + a5 * <span class="number">49</span> + a6 * <span class="number">89</span> + a7 * <span class="number">23</span> + a8 * <span class="number">56</span> - a9 * <span class="number">92</span> + a10 * <span class="number">14</span> + a11 * <span class="number">89</span> + a12 * <span class="number">47</span> - a13 * <span class="number">61</span> - a14 * <span class="number">29</span> == <span class="number">29250</span>) &amp; (a1 * <span class="number">95</span> + a2 * <span class="number">34</span> + a3 * <span class="number">62</span> - a4 * <span class="number">9</span> - a5 * <span class="number">43</span> + a6 * <span class="number">83</span> + a7 * <span class="number">25</span> + a8 * <span class="number">12</span> - a9 * <span class="number">36</span> + a10 * <span class="number">16</span> + a11 * <span class="number">51</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> - a14 * <span class="number">24</span> == <span class="number">15317</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;flag is GWHT&#123;md5(your_input)&#125;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Congratulations and have fun!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Sorry,plz try again...&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h5 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a1=Int(<span class="string">&#x27;a1&#x27;</span>)</span><br><span class="line">a2=Int(<span class="string">&#x27;a2&#x27;</span>)</span><br><span class="line">a3=Int(<span class="string">&#x27;a3&#x27;</span>)</span><br><span class="line">a4=Int(<span class="string">&#x27;a4&#x27;</span>)</span><br><span class="line">a5=Int(<span class="string">&#x27;a5&#x27;</span>)</span><br><span class="line">a6=Int(<span class="string">&#x27;a6&#x27;</span>)</span><br><span class="line">a7=Int(<span class="string">&#x27;a7&#x27;</span>)</span><br><span class="line">a8=Int(<span class="string">&#x27;a8&#x27;</span>)</span><br><span class="line">a9=Int(<span class="string">&#x27;a9&#x27;</span>)</span><br><span class="line">a10=Int(<span class="string">&#x27;a10&#x27;</span>)</span><br><span class="line">a11=Int(<span class="string">&#x27;a11&#x27;</span>)</span><br><span class="line">a12=Int(<span class="string">&#x27;a12&#x27;</span>)</span><br><span class="line">a13=Int(<span class="string">&#x27;a13&#x27;</span>)</span><br><span class="line">a14=Int(<span class="string">&#x27;a14&#x27;</span>)</span><br><span class="line">s=Solver()</span><br><span class="line">s.add(a1 * <span class="number">88</span> + a2 * <span class="number">67</span> + a3 * <span class="number">65</span> - a4 * <span class="number">5</span> + a5 * <span class="number">43</span> + a6 * <span class="number">89</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">36</span> + a10 * <span class="number">15</span> + a11 * <span class="number">11</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> + a14 * <span class="number">29</span> == <span class="number">22748</span>)</span><br><span class="line">s.add(a1 * <span class="number">89</span> + a2 * <span class="number">7</span> + a3 * <span class="number">12</span> - a4 * <span class="number">25</span> + a5 * <span class="number">41</span> + a6 * <span class="number">23</span> + a7 * <span class="number">20</span> - a8 * <span class="number">66</span> + a9 * <span class="number">31</span> + a10 * <span class="number">8</span> + a11 * <span class="number">2</span> - a12 * <span class="number">41</span> - a13 * <span class="number">39</span> + a14 * <span class="number">17</span> == <span class="number">7258</span>)</span><br><span class="line">s.add(a1 * <span class="number">28</span> + a2 * <span class="number">35</span> + a3 * <span class="number">16</span> - a4 * <span class="number">65</span> + a5 * <span class="number">53</span> + a6 * <span class="number">39</span> + a7 * <span class="number">27</span> + a8 * <span class="number">15</span> - a9 * <span class="number">33</span> + a10 * <span class="number">13</span> + a11 * <span class="number">101</span> + a12 * <span class="number">90</span> - a13 * <span class="number">34</span> + a14 * <span class="number">23</span> == <span class="number">26190</span>)</span><br><span class="line">s.add(a1 * <span class="number">23</span> + a2 * <span class="number">34</span> + a3 * <span class="number">35</span> - a4 * <span class="number">59</span> + a5 * <span class="number">49</span> + a6 * <span class="number">81</span> + a7 * <span class="number">25</span> + a8 * <span class="number">128</span> - a9 * <span class="number">32</span> + a10 * <span class="number">75</span> + a11 * <span class="number">81</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> + a14 * <span class="number">29</span> == <span class="number">37136</span>)</span><br><span class="line">s.add(a1 * <span class="number">38</span> + a2 * <span class="number">97</span> + a3 * <span class="number">35</span> - a4 * <span class="number">52</span> + a5 * <span class="number">42</span> + a6 * <span class="number">79</span> + a7 * <span class="number">90</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span> + a10 * <span class="number">57</span> + a11 * <span class="number">81</span> + a12 * <span class="number">42</span> - a13 * <span class="number">62</span> - a14 * <span class="number">11</span> == <span class="number">27915</span>)</span><br><span class="line">s.add(a1 * <span class="number">22</span> + a2 * <span class="number">27</span> + a3 * <span class="number">35</span> - a4 * <span class="number">45</span> + a5 * <span class="number">47</span> + a6 * <span class="number">49</span> + a7 * <span class="number">29</span> + a8 * <span class="number">18</span> - a9 * <span class="number">26</span> + a10 * <span class="number">35</span> + a11 * <span class="number">41</span> + a12 * <span class="number">40</span> - a13 * <span class="number">61</span> + a14 * <span class="number">28</span> == <span class="number">17298</span>)</span><br><span class="line">s.add(a1 * <span class="number">12</span> + a2 * <span class="number">45</span> + a3 * <span class="number">35</span> - a4 * <span class="number">9</span> - a5 * <span class="number">42</span> + a6 * <span class="number">86</span> + a7 * <span class="number">23</span> + a8 * <span class="number">85</span> - a9 * <span class="number">47</span> + a10 * <span class="number">34</span> + a11 * <span class="number">76</span> + a12 * <span class="number">43</span> - a13 * <span class="number">44</span> + a14 * <span class="number">65</span> == <span class="number">19875</span>)</span><br><span class="line">s.add(a1 * <span class="number">79</span> + a2 * <span class="number">62</span> + a3 * <span class="number">35</span> - a4 * <span class="number">85</span> + a5 * <span class="number">33</span> + a6 * <span class="number">79</span> + a7 * <span class="number">86</span> + a8 * <span class="number">14</span> - a9 * <span class="number">30</span> + a10 * <span class="number">25</span> + a11 * <span class="number">11</span> + a12 * <span class="number">57</span> - a13 * <span class="number">50</span> - a14 * <span class="number">9</span> == <span class="number">22784</span>)</span><br><span class="line">s.add(a1 * <span class="number">8</span> + a2 * <span class="number">6</span> + a3 * <span class="number">64</span> - a4 * <span class="number">85</span> + a5 * <span class="number">73</span> + a6 * <span class="number">29</span> + a7 * <span class="number">2</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span> + a10 * <span class="number">5</span> + a11 * <span class="number">2</span> + a12 * <span class="number">47</span> - a13 * <span class="number">64</span> + a14 * <span class="number">27</span> == <span class="number">9710</span>)</span><br><span class="line">s.add(a1 * <span class="number">67</span> - a2 * <span class="number">68</span> + a3 * <span class="number">68</span> - a4 * <span class="number">51</span> - a5 * <span class="number">43</span> + a6 * <span class="number">81</span> + a7 * <span class="number">22</span> - a8 * <span class="number">12</span> - a9 * <span class="number">38</span> + a10 * <span class="number">75</span> + a11 * <span class="number">41</span> + a12 * <span class="number">27</span> - a13 * <span class="number">52</span> + a14 * <span class="number">31</span> == <span class="number">13376</span>)</span><br><span class="line">s.add(a1 * <span class="number">85</span> + a2 * <span class="number">63</span> + a3 * <span class="number">5</span> - a4 * <span class="number">51</span> + a5 * <span class="number">44</span> + a6 * <span class="number">36</span> + a7 * <span class="number">28</span> + a8 * <span class="number">15</span> - a9 * <span class="number">6</span> + a10 * <span class="number">45</span> + a11 * <span class="number">31</span> + a12 * <span class="number">7</span> - a13 * <span class="number">67</span> + a14 * <span class="number">78</span> == <span class="number">24065</span>)</span><br><span class="line">s.add(a1 * <span class="number">47</span> + a2 * <span class="number">64</span> + a3 * <span class="number">66</span> - a4 * <span class="number">5</span> + a5 * <span class="number">43</span> + a6 * <span class="number">112</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">35</span> + a10 * <span class="number">95</span> + a11 * <span class="number">21</span> + a12 * <span class="number">43</span> - a13 * <span class="number">61</span> + a14 * <span class="number">20</span> == <span class="number">27687</span>)</span><br><span class="line">s.add(a1 * <span class="number">89</span> + a2 * <span class="number">67</span> + a3 * <span class="number">85</span> - a4 * <span class="number">25</span> + a5 * <span class="number">49</span> + a6 * <span class="number">89</span> + a7 * <span class="number">23</span> + a8 * <span class="number">56</span> - a9 * <span class="number">92</span> + a10 * <span class="number">14</span> + a11 * <span class="number">89</span> + a12 * <span class="number">47</span> - a13 * <span class="number">61</span> - a14 * <span class="number">29</span> == <span class="number">29250</span>)</span><br><span class="line">s.add(a1 * <span class="number">95</span> + a2 * <span class="number">34</span> + a3 * <span class="number">62</span> - a4 * <span class="number">9</span> - a5 * <span class="number">43</span> + a6 * <span class="number">83</span> + a7 * <span class="number">25</span> + a8 * <span class="number">12</span> - a9 * <span class="number">36</span> + a10 * <span class="number">16</span> + a11 * <span class="number">51</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> - a14 * <span class="number">24</span> == <span class="number">15317</span>)</span><br><span class="line"><span class="keyword">if</span> s.check()==sat:</span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br><span class="line"><span class="comment">#a2 = 24,a13 = 88,a14 = 33,a6 = 43,a9 = 52,</span></span><br><span class="line"><span class="comment">#a5 = 104,a12 = 74,a7 = 28,a1 = 119,a10 = 108,</span></span><br><span class="line"><span class="comment">#a11 = 88,a8 = 91,a4 = 7,a3 = 10</span></span><br><span class="line">s=[<span class="number">119</span>,<span class="number">24</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">104</span>,<span class="number">43</span>,<span class="number">28</span>,<span class="number">91</span>,<span class="number">52</span>,<span class="number">108</span>,<span class="number">88</span>,<span class="number">74</span>,<span class="number">88</span>,<span class="number">33</span>]</span><br><span class="line">index=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>]</span><br><span class="line">data=[<span class="number">0</span>]*<span class="number">14</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(index)):</span><br><span class="line">data[i]=s[index[i]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(index)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">data[i]^=data[i+<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">flag+=<span class="built_in">chr</span>(data[i])</span><br><span class="line">m=hashlib.md5()</span><br><span class="line">m.update(flag.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag&#123;&#x27;</span>+m.hexdigest()+<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyinstaller </tag>
            
            <tag> 羊城杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day3 网鼎杯2020 bang（Android逆向教学）</title>
      <link href="/2024/10/24/%E7%AC%AC%E5%8D%81%E7%AF%87/"/>
      <url>/2024/10/24/%E7%AC%AC%E5%8D%81%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="安装frida、frida-tools、frida-dexdump"><a href="#安装frida、frida-tools、frida-dexdump" class="headerlink" title="安装frida、frida-tools、frida-dexdump"></a>安装frida、frida-tools、frida-dexdump</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install frida</span><br><span class="line">pip install frida-tools</span><br><span class="line">pip install frida-dexdump</span><br><span class="line"></span><br><span class="line">如果网络环境不好，可以加 -i https://pypi.doubanio.com/simple/ --trusted-host pypi.doubanio.com 指定国内源</span><br></pre></td></tr></table></figure><h4 id="查壳工具"><a href="#查壳工具" class="headerlink" title="查壳工具"></a>查壳工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Apkcheck：https://github.com/moyuwa/ApkCheckPack/</span><br><span class="line"></span><br><span class="line">使用参数-s=true（默认false）开启全文件硬编码信息扫描</span><br><span class="line">ApkCheckPack.exe -s=false -f &lt;apk文件路径&gt;</span><br></pre></td></tr></table></figure><p><img src="/2024/10/24/%E7%AC%AC%E5%8D%81%E7%AF%87/1.png"></p><h4 id="配置frida-server"><a href="#配置frida-server" class="headerlink" title="配置frida-server"></a>配置frida-server</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、首先找一个真机或模拟器，安装好目标应用，并打开开发者选项，开启USB调试；</span><br><span class="line">2、如果是模拟器，配置好USB调试后，找到模拟器的adb.exe位置，在这个目录下打开cmd，输入adb devices，查看是否连接成功；</span><br><span class="line">3、利用 adb shell 命令，进入手机的shell环境，输入 getprop ro.product.cpu.abi 查看手机框架，我是 x86_64</span><br><span class="line">4、回到windows，利用 pip list | findstr frida* 查看frida的版本，我这里是 16.5.6</span><br><span class="line">5、所以我要下载 frida-server-16.5.6-android-x86_64.xz 文件，地址：https://github.com/frida/frida/releases</span><br><span class="line">6、解压后，在 cmd 里输入 adb push frida-server /data/local/tmp/，把 frida-server 上传到手机的 /data/local/tmp/ 目录下</span><br><span class="line">7、在 手机的shell环境中，输入 cd /data/local/tmp/，然后输入 chmod 777 frida-server，赋予执行权限，如果显示 Permission denied 则需要先输入 su 切换到 root 用户</span><br><span class="line">8、然后运行 frida-server，输入 ./frida-server，等待连接成功</span><br></pre></td></tr></table></figure><h4 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、在模拟器中，脱壳的app</span><br><span class="line">2、利用 APK Extractor pro 的app或其他方法，查看app的包名，例如本题的包名是 com.example.how_debug</span><br><span class="line">3、回到windows，进入python环境，输入 frida-ps -U，查看手机上运行的frida-server进程</span><br><span class="line">4、利用 frida-dexdump -U -f com.example.how_debug -d -o ./com.example.how_debug，com.xxx.xxx是程序的包名，脱壳后文件保存在当前目录下的包名文件</span><br><span class="line">5、这样com.example.how_debug目录下就会有很多dex文件</span><br></pre></td></tr></table></figure><h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><p>这里用到一个python反编译合并脚本，根据配置一下三个路径即可，然后运行脚本即可<br><img src="/2024/10/24/%E7%AC%AC%E5%8D%81%E7%AF%87/2.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename_class</span>(<span class="params">path</span>):</span><br><span class="line">    files = os.listdir(path)</span><br><span class="line">    dex_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> path.endswith(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">        path = path[:-<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(files)):</span><br><span class="line">        <span class="keyword">if</span> files[i].endswith(<span class="string">&#x27;.dex&#x27;</span>):</span><br><span class="line">            old_name = path + <span class="string">&#x27;/&#x27;</span> + files[i]</span><br><span class="line">            <span class="keyword">if</span> dex_index == <span class="number">0</span>:</span><br><span class="line">                new_name = path + <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;classes.dex&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_name = path + <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;classes%d.dex&#x27;</span> % dex_index</span><br><span class="line">            dex_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(new_name):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            os.rename(old_name, new_name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[*] 重命名完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_META_INF_from_apk</span>(<span class="params">apk_path, target_path</span>):</span><br><span class="line">    r = zipfile.is_zipfile(apk_path)</span><br><span class="line">    <span class="keyword">if</span> r:</span><br><span class="line">        fz = zipfile.ZipFile(apk_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> fz.namelist():</span><br><span class="line">            <span class="keyword">if</span> file.startswith(<span class="string">&#x27;META-INF&#x27;</span>):</span><br><span class="line">                fz.extract(file, target_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[-] %s 不是一个APK文件&#x27;</span> % apk_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zip_dir</span>(<span class="params">dirname, zipfilename</span>):</span><br><span class="line">    filelist = []</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(dirname):</span><br><span class="line">        <span class="keyword">if</span> dirname.endswith(<span class="string">&#x27;.dex&#x27;</span>):</span><br><span class="line">            filelist.append(dirname)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dirname):</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> dirs:</span><br><span class="line">                <span class="comment"># if dir == &#x27;META-INF&#x27;:</span></span><br><span class="line">                <span class="comment"># print(&#x27;dir:&#x27;, os.path.join(root, dir))</span></span><br><span class="line">                filelist.append(os.path.join(root, <span class="built_in">dir</span>))</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">                <span class="comment"># print(&#x27;file:&#x27;, os.path.join(root, name))</span></span><br><span class="line"></span><br><span class="line">                filelist.append(os.path.join(root, name))</span><br><span class="line"></span><br><span class="line">    z = zipfile.ZipFile(zipfilename, <span class="string">&#x27;w&#x27;</span>, zipfile.ZIP_DEFLATED)</span><br><span class="line">    <span class="keyword">for</span> tar <span class="keyword">in</span> filelist:</span><br><span class="line">        arcname = tar[<span class="built_in">len</span>(dirname):]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;META-INF&#x27;</span> <span class="keyword">in</span> arcname <span class="keyword">or</span> arcname.endswith(<span class="string">&#x27;.dex&#x27;</span>)) <span class="keyword">and</span> <span class="string">&#x27;.DS_Store&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> arcname:</span><br><span class="line">            <span class="comment"># print(tar + &quot; --&gt;rar: &quot; + arcname)</span></span><br><span class="line">            z.write(tar, arcname)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[*] APK打包成功，你可以拖入APK进行分析啦！&#x27;</span>)</span><br><span class="line">    z.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    args = &#123;</span><br><span class="line">        <span class="string">&#x27;dex_path&#x27;</span>: <span class="string">&#x27;./files/com.example.how_debug&#x27;</span>,  <span class="comment"># 脱壳后dex路径</span></span><br><span class="line">        <span class="string">&#x27;apk_path&#x27;</span>: <span class="string">&#x27;./signed.apk&#x27;</span>,  <span class="comment"># 原始带壳apk路径</span></span><br><span class="line">        <span class="string">&#x27;output&#x27;</span>: <span class="string">&#x27;./apk/output.apk&#x27;</span>  <span class="comment"># 脱壳后apk路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rename_class(args[<span class="string">&#x27;dex_path&#x27;</span>])</span><br><span class="line">    extract_META_INF_from_apk(args[<span class="string">&#x27;apk_path&#x27;</span>], args[<span class="string">&#x27;dex_path&#x27;</span>])</span><br><span class="line">    zip_dir(args[<span class="string">&#x27;dex_path&#x27;</span>], args[<span class="string">&#x27;output&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="拖入jadx中分析"><a href="#拖入jadx中分析" class="headerlink" title="拖入jadx中分析"></a>拖入jadx中分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jadx下载地址：https://github.com/skylot/jadx/releases</span><br><span class="line">可以下这个不用配置java环境 jadx-gui-1.5.0-with-jre-win.zip</span><br><span class="line"></span><br><span class="line">1、打开 jadx-gui-1.5.0-with-jre-win\jadx-gui-1.5.0.exe，将合并后的apk文件直接拖入分析</span><br><span class="line">2、源代码 -&gt; com -&gt; example.how_debug -&gt; MainActivity 找到主界面，就可以看到flag</span><br><span class="line">3、或者直接全局文本搜索 flag&#123; 也可看到flag</span><br></pre></td></tr></table></figure><p><img src="/2024/10/24/%E7%AC%AC%E5%8D%81%E7%AF%87/3.png"></p>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网鼎杯 </tag>
            
            <tag> Android逆向 </tag>
            
            <tag> frida </tag>
            
            <tag> jadx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TEA系列算法入门</title>
      <link href="/2024/10/17/%E7%AC%AC%E5%85%AB%E7%AF%87/"/>
      <url>/2024/10/17/%E7%AC%AC%E5%85%AB%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="TEA系列算法介绍"><a href="#TEA系列算法介绍" class="headerlink" title="TEA系列算法介绍"></a>TEA系列算法介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEA算法使用64位的明文分组和128位的密钥，它使用Feistel分组加密框架，需要进行 64 轮迭代。该算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 0×9E3779B9）。之后 TEA 算法被发现存在缺陷，作为回应，设计者提出了一个 TEA 的升级版本——XTEA（有时也被称为“tean”）。XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合，但速度更慢了。</span><br></pre></td></tr></table></figure><h4 id="TEA算法流程图（一次加密）"><a href="#TEA算法流程图（一次加密）" class="headerlink" title="TEA算法流程图（一次加密）"></a>TEA算法流程图（一次加密）</h4><p><img src="/2024/10/17/%E7%AC%AC%E5%85%AB%E7%AF%87/1.png"></p><h4 id="TEA算法加密、解密代码"><a href="#TEA算法加密、解密代码" class="headerlink" title="TEA算法加密、解密代码"></a>TEA算法加密、解密代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密代码：</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">  sum += delta;</span><br><span class="line">  v0 += ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">  v1 += ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简化加密：</span></span><br><span class="line">v0<span class="number">&#x27;</span> = v0 + fun1(v1);</span><br><span class="line">v1<span class="number">&#x27;</span> = v1 + fun2(v0<span class="number">&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化解密代码：</span></span><br><span class="line">v1 = v1<span class="number">&#x27;</span> - fun2(v0<span class="number">&#x27;</span>);</span><br><span class="line">v0 = v0<span class="number">&#x27;</span> - fun1(v1<span class="number">&#x27;</span>);</span><br><span class="line"><span class="comment">// 解密代码：</span></span><br><span class="line">sum = delta * <span class="number">64</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">  v1 -= ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);</span><br><span class="line">  v0 -= ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);</span><br><span class="line">  sum -= delta;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="TEA基于c语言的解密脚本"><a href="#TEA基于c语言的解密脚本" class="headerlink" title="TEA基于c语言的解密脚本"></a>TEA基于c语言的解密脚本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> data[<span class="number">6</span>] = &#123; <span class="number">3746099070</span>,<span class="number">550153460</span>,<span class="number">3774025685</span>,<span class="number">1548802262</span>,<span class="number">2652626477</span>,<span class="number">2230518816</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tmp1, tmp2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v3, v4;</span><br><span class="line"><span class="type">int</span> key[<span class="number">4</span>] = &#123; <span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">v3 = data[i];</span><br><span class="line">v4 = data[i + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> v5 = <span class="number">1166789954</span> * <span class="number">64</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">v4 -= (v3 + v5 + <span class="number">20</span>) ^ ((v3 &lt;&lt; <span class="number">6</span>) + key[<span class="number">2</span>]) ^ ((v3 &gt;&gt; <span class="number">9</span>) + key[<span class="number">3</span>]) ^ <span class="number">0x10</span>;</span><br><span class="line">v3 -= (v4 + v5 + <span class="number">11</span>) ^ ((v4 &lt;&lt; <span class="number">6</span>) + key[<span class="number">0</span>]) ^ ((v4 &gt;&gt; <span class="number">9</span>) + key[<span class="number">1</span>]) ^ <span class="number">0x20</span>;</span><br><span class="line">v5 -= <span class="number">1166789954</span>;</span><br><span class="line">&#125;</span><br><span class="line">data[i] = v3;</span><br><span class="line">data[i + <span class="number">1</span>] = v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c%c%c&quot;</span>, *((<span class="type">char</span>*)&amp;data[i] + <span class="number">2</span>), *((<span class="type">char</span>*)&amp;data[i] + <span class="number">1</span>), *(<span class="type">char</span>*)&amp;data[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="XTEA算法相对TEA算法的变化"><a href="#XTEA算法相对TEA算法的变化" class="headerlink" title="XTEA算法相对TEA算法的变化"></a>XTEA算法相对TEA算法的变化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、由之前的((v1&lt;&lt;4) + k0) ^ (v1&gt;&gt;5)) + k1 变成了((v1&lt;&lt;4) ^ (v1&gt;&gt;5) + v1)，此时v1内部数据不再受到密钥的影响。</span><br><span class="line">2、原先的 v1 + sum 变成了 (sum + key[sum &amp; 3]) 以及 sum + key[sum&gt;&gt;2 &amp; 3]，密钥变成了轮转使用，而不是固定只</span><br><span class="line">针对某种数据进行加密（解密）。并且此时密钥的选取收到了sum的影响。</span><br><span class="line">3、sum += delta的位置变到了v0，v1两个block加密的中间。</span><br></pre></td></tr></table></figure><h4 id="XTEA算法加密、解密代码"><a href="#XTEA算法加密、解密代码" class="headerlink" title="XTEA算法加密、解密代码"></a>XTEA算法加密、解密代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密代码：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, delta=<span class="number">0x9E3779B9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密代码：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], delta=<span class="number">0x9E3779B9</span>, sum=delta*num_rounds;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="XXTEA算法"><a href="#XXTEA算法" class="headerlink" title="XXTEA算法"></a>XXTEA算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点：在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥, 是目前TEA系列中最安全的算法，但性能较上两种有所降低。</span><br></pre></td></tr></table></figure><h4 id="XXTEA算法流程图"><a href="#XXTEA算法流程图" class="headerlink" title="XXTEA算法流程图"></a>XXTEA算法流程图</h4><p><img src="/2024/10/17/%E7%AC%AC%E5%85%AB%E7%AF%87/2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、可以利用python自带的xxtea模块进行解密</span><br><span class="line">2、基于c语言的解密代码如下：</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p+<span class="number">1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">4</span>]= &#123;<span class="number">0x73647979</span>,<span class="number">0x726b6f5f</span>,<span class="number">0x646f675f</span>,<span class="number">0x0</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= &#123;<span class="number">0X95C4C</span>,<span class="number">0X871D</span>,<span class="number">0X1A7B7</span>,<span class="number">0X12C7C7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n= <span class="number">2</span>; <span class="comment">//n的绝对值表示v的长度，取正表示加密，取负表示解密</span></span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密前原始数据：%s\n&quot;</span>,(<span class="type">char</span>*)v);</span><br><span class="line">    btea(v, n, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的数据：%u %u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>],v[<span class="number">3</span>]);</span><br><span class="line">    btea(v, -n, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;解密后的数据：%s\n&quot;</span>,(<span class="type">char</span>*)v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> TEA系列算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day2 十分钟带你解决逆向中对称加密算法 (RC4)</title>
      <link href="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/"/>
      <url>/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="流加密算法"><a href="#流加密算法" class="headerlink" title="流加密算法"></a>流加密算法</h4><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流加密算法（Stream Cipher），是一种加密方式，它通过将明文与一个随机生成的密钥流进行逐位或逐字节异或操作来产生密文。</span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">密钥流生成器（Key Stream Generator）：流加密算法的核心是密钥流生成器，它使用一个短的密钥（种子密钥）</span><br><span class="line">来生成一个长的密钥流。这个密钥流决定了加密的随机性和强度。</span><br><span class="line"></span><br><span class="line">异或操作（XOR Operation）：明文数据与密钥流进行异或操作，生成密文。解密时，密文与同一密钥流再次进行</span><br><span class="line">异或操作，恢复出明文。</span><br></pre></td></tr></table></figure><h4 id="RC4算法介绍"><a href="#RC4算法介绍" class="headerlink" title="RC4算法介绍"></a>RC4算法介绍</h4><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种串流加密算法，密钥长度可变。他加密解密使用</span><br><span class="line">相同的密钥，因此也被称为“流加密算法”。RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，</span><br><span class="line">范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。</span><br><span class="line">S盒用来加密数据，而且在加密过程中S盒会变化。由于异或运算的对合性，RC4加密解密使用同一套算法。</span><br></pre></td></tr></table></figure><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、初始化S-Box</span><br><span class="line">2、KSA过程（置乱刚刚初始化完成的S表）</span><br><span class="line">  - 初始化密钥（可无可有）</span><br><span class="line">  - 置乱过程（KSA）</span><br><span class="line">3、PRGA过程（生成密钥流，用于与明文进行异或生成密文）</span><br></pre></td></tr></table></figure><h4 id="RC4算法刨析"><a href="#RC4算法刨析" class="headerlink" title="RC4算法刨析"></a>RC4算法刨析</h4><h4 id="第一步：初始化S-Box"><a href="#第一步：初始化S-Box" class="headerlink" title="第一步：初始化S-Box"></a>第一步：初始化S-Box</h4><p>具体过程如下图所示，其实就是从0~255填充满大小为256的数组。<br><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/1.png"></p><h4 id="第二步：KSA过程"><a href="#第二步：KSA过程" class="headerlink" title="第二步：KSA过程"></a>第二步：KSA过程</h4><h4 id="初始化密钥"><a href="#初始化密钥" class="headerlink" title="初始化密钥"></a>初始化密钥</h4><p>上面我们有了最初的S-Box，那么对于KSA的核心作用呢，实际上是通过密钥来置乱初始的向量，这个初始向量是一个固定值，从0~255来填充满S-Box。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这一步呢其实在编码过程当中是可有可无的，如果我们不生成T-Box，可以在编码过程当中模KeyLen来实现，如果使用T-Box，那么我们在编码过程当中需要模256了，这里展示使用T-Box的情况，和文章最开头的流程图保持一致。对于T-Box来说，其实就是密钥循环复制m次，使得循环之后充满256长度的数组，从这里可以直观的看出，对于RC4来说，它的密钥长度大小最大是256。</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/2.jpg"></p><h4 id="置乱过程-KSA"><a href="#置乱过程-KSA" class="headerlink" title="置乱过程(KSA)"></a>置乱过程(KSA)</h4><p><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/3.jpg"></p><h4 id="KSA整体流程图"><a href="#KSA整体流程图" class="headerlink" title="KSA整体流程图"></a>KSA整体流程图</h4><p><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/4.png"></p><h4 id="第三步：PRGA过程"><a href="#第三步：PRGA过程" class="headerlink" title="第三步：PRGA过程"></a>第三步：PRGA过程</h4><p>这个过程是整个RC4算法的核心，通过这个过程生成我们需要的PRNG序列，具体过程如下图所示。<br><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/5.jpg"></p><h4 id="PRGA整体流程图"><a href="#PRGA整体流程图" class="headerlink" title="PRGA整体流程图"></a>PRGA整体流程图</h4><p><img src="/2024/10/15/%E7%AC%AC%E5%85%AD%E7%AF%87/6.png"></p><h4 id="解决逆向中对称加密算法的小技巧"><a href="#解决逆向中对称加密算法的小技巧" class="headerlink" title="解决逆向中对称加密算法的小技巧"></a>解决逆向中对称加密算法的小技巧</h4><h4 id="使用工具："><a href="#使用工具：" class="headerlink" title="使用工具："></a>使用工具：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LazyIDA：具体可以看我的bilibili上的视频教程，提供插件下载。</span><br><span class="line"></span><br><span class="line">主要作用：</span><br><span class="line">自动重定位跳转</span><br><span class="line">数据格式转换</span><br><span class="line">粘贴数据到指定内存</span><br><span class="line">DUMP指定内存到文件</span><br><span class="line">修改内存数据</span><br></pre></td></tr></table></figure><h4 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">首先我们知道流加密算法的加密和解密过程是相同的，我们输入的明文会被加密为密文，那么如果我们输入</span><br><span class="line">的是密文那么得到是不是就是我们要的明文，所以我们要想办法获得密文，一般逆向过程是，我们输入字符串</span><br><span class="line">然后程序进行加密，得到加密后的密文，与正确的flag密文进行比较，如果相同，那么则正确。</span><br><span class="line"></span><br><span class="line">那么我们可以使用LazyIDA中带有提取特定数据格式和修改内存数据的功能，通过提取内存中的密文，然后作为</span><br><span class="line">输入，进行解密，得到flag，因为提取的密文可能会带有不可见字符，所以需要LazyIDA插件。</span><br><span class="line"></span><br><span class="line">具体可以看我的bilibili上的视频教程，有例题讲解。</span><br></pre></td></tr></table></figure><h4 id="bilibili视频教程"><a href="#bilibili视频教程" class="headerlink" title="bilibili视频教程"></a>bilibili视频教程</h4><p><a href="https://www.bilibili.com/video/BV1i3xDeZE7H/?share_source=copy_web&vd_source=cb1799ab55ca5d1f2c72c3c2c11d5e74">十分钟带你解决逆向中对称加密算法（RC40)</a></p>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> RC4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>番外篇：网鼎杯2020 signal（Ponce插件的使用）</title>
      <link href="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/"/>
      <url>/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="VM知识："><a href="#VM知识：" class="headerlink" title="VM知识："></a>VM知识：</h4><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/10.png"></p><p>分析流程：<br><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/11.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm_start :虚拟机入口函数 ，初始化虚拟机</span><br><span class="line">vm_dispatcher: 调度器，解释op_code,并选择相应的函数执行，当函数执行完后会返回这里，形成一个循环，直到执行完</span><br><span class="line">vm_code:程序可执行代码形成的操作码</span><br></pre></td></tr></table></figure><h4 id="Ponce的简述："><a href="#Ponce的简述：" class="headerlink" title="Ponce的简述："></a>Ponce的简述：</h4><p>对于Ponce来说只需要关心那里输入，哪里success，哪里wrong。<br>Ponce是一款IDAPro插件，该工具采用C&#x2F;C++开发，它可以帮助用户以一种快速简洁的方式对目标代码进行<br>污点测试以及符号执行。用户只需点一下鼠标或者按一下键盘，剩下的就可以交给Ponce了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + M ：符号化（找到输入的参数将其变为符号变量）</span><br></pre></td></tr></table></figure><h4 id="符号执行："><a href="#符号执行：" class="headerlink" title="符号执行："></a>符号执行：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">传统符号执行是一种静态分析技术，最初在1976年由King JC在ACM上提出。即通过使用抽象的符号代替具体值来模拟程序的执行，当遇到分支语句时，它会探索每一个分支, 将分支条件加入到相应的路径约束中，若约束可解，则说明该路径是可达的。</span><br><span class="line"></span><br><span class="line">在遇到程序分支指令时, 程序的执行也相应地搜索每个分支, 分支条件被加入到符号执行保存的符号路径约束 PC, PC表示当前路径的约束条件。在收集了路径约束条件之后, 使用约束求解器来验证约束的可解性, 以确定该路径是否可达。若该路径约束可解, 则说明该路径是可达的;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大概原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">符号：符号是代表一组可能值的抽象。例如，一个符号 x 可能代表任意整数。</span><br><span class="line">路径约束：在执行过程中，程序的控制流会根据条件分支创建不同的执行路径。符号执行会收集这些条件分支的约束，形成路径约束。</span><br></pre></td></tr></table></figure><p>执行过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始化：符号执行开始时，程序输入（如函数参数、全局变量等）被赋予符号值。</span><br><span class="line">执行：程序按照正常流程执行，但所有操作都是对符号值进行的。</span><br><span class="line">路径探索：在遇到条件分支时，符号执行会探索所有可能的路径。对于每个分支，它都会假设条件为真和假，并分别记录下相应的路径约束。</span><br><span class="line">约束求解：符号执行完成后，分析人员可以对这些路径约束进行求解，以找到满足特定路径的具体输入值。</span><br></pre></td></tr></table></figure><h4 id="例题讲解："><a href="#例题讲解：" class="headerlink" title="例题讲解："></a>例题讲解：</h4><h5 id="Ponce符号执行："><a href="#Ponce符号执行：" class="headerlink" title="Ponce符号执行："></a>Ponce符号执行：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、首先一定在输入字符串的地方打下断点，我们要在字符串开始变化之前将他定义为符号变量以记录路径约束，也方便找到我我们输入的字符串的位置，先找到scanf的那段代码，Tab查看他的汇编代码，在call _scanf 下面打下断点</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2、接着在判断的地方打一个断点，用来约束求解，去找到我们想要的值</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/2.png"><br><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3、紧接着开始调试执行程序</span><br><span class="line">4、输入字符串为了便于识别输入 123456789012345</span><br><span class="line">5、找到字符串在十六进制中的地址，并将其符号化</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/4.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6、选中31，按Ctrl + Shift + M，将其符号化，长度为15</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/5.png"><br><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7、F9执行到判断的断点哪里，然后右键选中 SMT Solver开始约束求解，结果在输出窗口那看</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/7.png"><br><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8、然后F7单步执行，会跳转到右边0x004016E6这个地址，我们在General registers窗口找到EIP将他的值改为0x004016FE 也就是跳转到左边的地址</span><br></pre></td></tr></table></figure><p><img src="/2024/10/15/%E7%AC%AC%E5%9B%9B%E7%AF%87/9.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9、重复15次即可</span><br></pre></td></tr></table></figure><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">opcode = [0x00000004, 0x00000010, 0x00000008, 0x00000003, 0x00000005, 0x00000001, 0x00000004, 0x00000020, 0x00000008, 0x00000005, 0x00000003, 0x00000001, 0x00000003, 0x00000002, 0x00000008, 0x0000000B, 0x00000001, 0x0000000C, 0x00000008, 0x00000004, 0x00000004, 0x00000001, 0x00000005, 0x00000003, 0x00000008, 0x00000003, 0x00000021, 0x00000001, 0x0000000B, 0x00000008, 0x0000000B, 0x00000001, 0x00000004, 0x00000009, 0x00000008, 0x00000003, 0x00000020, 0x00000001, 0x00000002, 0x00000051, 0x00000008, 0x00000004, 0x00000024, 0x00000001, 0x0000000C, 0x00000008, 0x0000000B, 0x00000001, 0x00000005, 0x00000002, 0x00000008, 0x00000002, 0x00000025, 0x00000001, 0x00000002, 0x00000036, 0x00000008, 0x00000004, 0x00000041, 0x00000001, 0x00000002, 0x00000020, 0x00000008, 0x00000005, 0x00000001, 0x00000001, 0x00000005, 0x00000003, 0x00000008, 0x00000002, 0x00000025, 0x00000001, 0x00000004, 0x00000009, 0x00000008, 0x00000003, 0x00000020, 0x00000001, 0x00000002, 0x00000041, 0x00000008, 0x0000000C, 0x00000001]</span><br><span class="line">arr1 = [0x22, 0x3F, 0x34, 0x32, 0x72, 0x33, 0x18, 0x000000A7, 0x31, 0x000000F1, 0x00000028, 0x00000084, 0x000000C1, 0x0000001E, 0x0000007A]</span><br><span class="line"></span><br><span class="line">def judge(eip, cnt):</span><br><span class="line">    _eip = eip</span><br><span class="line">    for j in range(48, 123):</span><br><span class="line">        flag = j</span><br><span class="line">        while _eip &lt; 83:</span><br><span class="line">            if opcode[_eip] == 2:</span><br><span class="line">                tmp = opcode[_eip + 1] + flag</span><br><span class="line">                _eip += 2</span><br><span class="line">            elif opcode[_eip] == 3:</span><br><span class="line">                tmp = flag - opcode[_eip + 1]</span><br><span class="line">                _eip += 2</span><br><span class="line">            elif opcode[_eip] == 4:</span><br><span class="line">                tmp = opcode[_eip + 1] ^ flag</span><br><span class="line">                _eip += 2</span><br><span class="line">            elif opcode[_eip] == 5:</span><br><span class="line">                tmp = opcode[_eip + 1] * flag</span><br><span class="line">                _eip += 2</span><br><span class="line">            elif opcode[_eip] == 6:</span><br><span class="line">                _eip += 1</span><br><span class="line">            elif opcode[_eip] == 8:</span><br><span class="line">                flag = tmp</span><br><span class="line">                _eip += 1</span><br><span class="line">            elif opcode[_eip] == 11:</span><br><span class="line">                tmp = flag - 1</span><br><span class="line">                _eip += 1</span><br><span class="line">            elif opcode[_eip] == 12:</span><br><span class="line">                tmp = flag + 1</span><br><span class="line">                _eip += 1</span><br><span class="line">            elif opcode[_eip] == 1:</span><br><span class="line">                if tmp == arr1[cnt]:</span><br><span class="line">                    # print(f&quot;&#123;cnt&#125;:&#123;chr(j)&#125;&quot;)</span><br><span class="line">                    print(f&quot;&#123;chr(j)&#125;&quot;, end=&#x27;&#x27;)</span><br><span class="line">                    _eip += 1</span><br><span class="line">                    return tmp</span><br><span class="line">                else:</span><br><span class="line">                    _eip = eip</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    bb = [0, 6, 12, 17, 22, 28, 32, 38, 44, 48, 54, 60, 66, 72, 78, 83]</span><br><span class="line">    for i in range(15):</span><br><span class="line">        mid = judge(bb[i], i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> IDA </tag>
            
            <tag> 网鼎杯 </tag>
            
            <tag> Ponce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day1 IDA入门教学</title>
      <link href="/2024/10/15/%E7%AC%AC%E4%BA%94%E7%AF%87/"/>
      <url>/2024/10/15/%E7%AC%AC%E4%BA%94%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="IDA介绍与快捷键的使用"><a href="#IDA介绍与快捷键的使用" class="headerlink" title="IDA介绍与快捷键的使用"></a>IDA介绍与快捷键的使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IDA 是一款功能强大的静态反汇编工具，可以帮助安全研究人员、黑客和软件开发人员理解和分析各种编译</span><br><span class="line">后的程序文件（如EXE、DLL、ELF等）。同时也拥有动态分析功能，可以跟踪运行时的程序行为。我们新手</span><br><span class="line">先学习IDA就足够了。</span><br></pre></td></tr></table></figure><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>静态反汇编快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Shift + F12                //进入字符串窗口，所有字符串都在这</span><br><span class="line">Ctrl + X                   //可以知道那个函数引用了这个字符串</span><br><span class="line">X                          //查看函数在哪里被引用了</span><br><span class="line">G                          //将地址复制下来之后，如果想要回去，按G输入地址即可</span><br><span class="line">ALT + T                    //文本搜索</span><br><span class="line">N                          //修改函数、变量的名称</span><br><span class="line">Ctrl + Z                   //撤销操作</span><br><span class="line">/                          //添加注释</span><br><span class="line">\                          //隐藏系统自己写上的注释</span><br><span class="line">D                          //转化为数据的形式</span><br><span class="line">A                          //转化为字符类型</span><br><span class="line">C                          //转化为汇编代码形式</span><br><span class="line">U                          //转化为原始的字节模式</span><br><span class="line">Shift + E                  //导出数据</span><br><span class="line">Ctrl + E                   //找到程序的起始位置</span><br><span class="line">R                          //将常量转化为单个字符</span><br><span class="line">Ctrl + k                   //打开函数的栈，查看用到了那些变量</span><br><span class="line">ALT + M                    //添加标记</span><br><span class="line">Ctrl + M                   //查看标记，双击跳转</span><br><span class="line">ESC                        //回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口）</span><br><span class="line">Tab                        //会从反汇编代码跳转到反汇编代码</span><br><span class="line">Y                          //修改类型</span><br></pre></td></tr></table></figure><p>动态调试快捷键：<br><img src="/2024/10/15/%E7%AC%AC%E4%BA%94%E7%AF%87/1.png"></p><h3 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路"></a>做题思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、先找main函数</span><br><span class="line">2、或者通过 Shift + F12 来查看字符串，了解大概的意思找到特殊的字符串（input，correct等字样）双击</span><br><span class="line">可以到达汇编的文本代码然后通过交叉引用 Ctrl + X 来查看那些函数引用了这个代码，也可以定位到main函数</span><br><span class="line">或其他重要函数</span><br><span class="line">3、通过 F5 反汇编成我们看得懂的代码</span><br><span class="line">4、然后看到下面的(_DWORD *)这个括号里面的是注释，我们可以右键点击&quot;Hide casts&quot;隐藏起来，或者通过 \ 键</span><br></pre></td></tr></table></figure><h3 id="使用IDA"><a href="#使用IDA" class="headerlink" title="使用IDA"></a>使用IDA</h3><p><img src="/2024/10/15/%E7%AC%AC%E4%BA%94%E7%AF%87/2.png"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDA的入门使用在bilibli上有更加详细实操的教程，欢迎大家参考学习。</span><br></pre></td></tr></table></figure><h3 id="bilibili视频教程"><a href="#bilibili视频教程" class="headerlink" title="bilibili视频教程"></a>bilibili视频教程</h3><p><a href="https://www.bilibili.com/video/BV1n2tkeSEcx/?share_source=copy_web">十分钟带你快速入门CTF逆向（保姆级教程）</a></p>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse前置知识点</title>
      <link href="/2024/10/13/%E7%AC%AC%E4%B8%83%E7%AF%87/"/>
      <url>/2024/10/13/%E7%AC%AC%E4%B8%83%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="IDA逆向代码段说明"><a href="#IDA逆向代码段说明" class="headerlink" title="IDA逆向代码段说明"></a>IDA逆向代码段说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text段：text段是代码段，包含了程序的执行指令，即程序的可执行机器代码。</span><br><span class="line">.idata段：idata段是导入数据段，包含了程序需要从外部动态链接库导入的函数和变量的信息。</span><br><span class="line">.rdata段：rdata段是只读数据段，包含了程序中使用的常量数据，如字符串、静态初始化的数组等，这些数据在程序运行期间不会被修改。</span><br><span class="line">.data段：data段是数据段，包含了程序中使用的可读写数据，如全局变量和静态变量。</span><br><span class="line"></span><br><span class="line">知识点：如果一个程序的入口地址为.text段大多不带壳，因为壳会将原来的EP（入口点）给覆盖。</span><br></pre></td></tr></table></figure><h2 id="汇编知识"><a href="#汇编知识" class="headerlink" title="汇编知识"></a>汇编知识</h2><h4 id="常见数据类型："><a href="#常见数据类型：" class="headerlink" title="常见数据类型："></a>常见数据类型：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 字节型（DB，8个字节）</span><br><span class="line">- 字型（DW，16个字节）</span><br><span class="line">- 双字型（DD，32个字节）</span><br><span class="line">- 四字型（DQ，64个字节）</span><br><span class="line">- 十字节型</span><br><span class="line">- 字符串型</span><br></pre></td></tr></table></figure><h4 id="寄存器知识点以及常见汇编代码："><a href="#寄存器知识点以及常见汇编代码：" class="headerlink" title="寄存器知识点以及常见汇编代码："></a>寄存器知识点以及常见汇编代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CS:IP：任意时刻，CPU将CS:IP指向的内容当作指令执行</span><br><span class="line">DS：通常存放要访问数据的段地址</span><br><span class="line">SS:SP：任意时刻，SS:SP指向栈顶元素，SP - 2</span><br><span class="line">loop：cx中存放循环的次数</span><br><span class="line">offset：取得标号的偏移地址</span><br><span class="line"></span><br><span class="line">函数调用：</span><br><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,N</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push xxx</span><br><span class="line">ret</span><br><span class="line">就相当于</span><br><span class="line">jmp xxx </span><br></pre></td></tr></table></figure><h5 id="常见寄存器及作用："><a href="#常见寄存器及作用：" class="headerlink" title="常见寄存器及作用："></a>常见寄存器及作用：</h5><table><thead><tr><th>寄存器</th><th>描述</th></tr></thead><tbody><tr><td>EAX</td><td>通用寄存器，用于存放函数返回值、算术运算结果等。</td></tr><tr><td>EBX</td><td>通用寄存器，用于存放内存地址或其他通用数据。</td></tr><tr><td>ECX</td><td>通用寄存器，用于存放函数参数。</td></tr><tr><td>EDX</td><td>通用寄存器，用于存放内存地址或其他通用数据。</td></tr><tr><td>ESI</td><td>通用寄存器，用于存放源数据的地址，例如字符串拷贝等操作。</td></tr><tr><td>EDI</td><td>通用寄存器，用于存放目标数据的地址，例如字符串拷贝等操作。</td></tr><tr><td>EBP</td><td>基址指针，用于存放当前栈帧的基址。</td></tr><tr><td>ESP</td><td>堆栈指针，用于存放当前堆栈顶部的地址。</td></tr><tr><td>EIP</td><td>指令指针，用于存放当前正在执行的指令的地址。</td></tr><tr><td>EFLAGS</td><td>标志寄存器，用于存放CPU的状态标志，例如进位标志、零标志、符号标志等。</td></tr></tbody></table><h4 id="常用的宏："><a href="#常用的宏：" class="headerlink" title="常用的宏："></a>常用的宏：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOWORD：取32位数的低16位  </span><br><span class="line">HIWORD：取32位数的高16位  </span><br><span class="line">LOBYTE：取16位数的低8位  </span><br><span class="line">HIBYTE：去16位数的高8位  </span><br></pre></td></tr></table></figure><h4 id="函数通过参数输入："><a href="#函数通过参数输入：" class="headerlink" title="函数通过参数输入："></a>函数通过参数输入：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在C语言中，main 函数是程序执行的入口点。int __cdecl main(int argc, const char **argv, const char **envp) 中的参数具有以下含义：</span><br><span class="line"></span><br><span class="line">int argc：这是 “argument count” 的缩写，代表传递给程序的命令行参数的数量。这包括程序名称本身，因此如果有一个命令行参数，argc 将是2。</span><br><span class="line"></span><br><span class="line">const char **argv：这是 “argument vector” 的缩写，代表一个指向字符串的指针数组，这些字符串包含了传递给程序的命令行参数。argv[0] 通常包含程序的名称或者一个指向程序名称的指针，argv[1] 是第一个命令行参数，依此类推。</span><br><span class="line"></span><br><span class="line">const char **envp：这是一个指向环境变量的指针数组。每个元素都是一个以 null 结尾的字符串，形式为 “变量=值”，表示程序的环境设置。例如，envp 可能包含像 PATH=/usr/bin 或 HOME=/home/user 这样的字符串。</span><br></pre></td></tr></table></figure><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更多逆向知识，在bilibili上有视频教程，欢迎大家参考学习。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Reverse_Preview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用简单的方法解决phpstudy中的mysql与本地mysql冲突问题</title>
      <link href="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/"/>
      <url>/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a><strong>前置知识：</strong></h2><p>我们首先要知道phpstudy中的mysql与本地的mysql有哪些冲突，首先是端口都是3306冲突了，其次可能是服务名相同导致了冲突。</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h3><p>只改变服务名程，但是两者不能同时启动</p><p>1、win + s，搜索Mysql Installer -community并点击进入</p><p><img src="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/1.png"></p><p>2、点击Reconifgure，进入后一直点击next并输入密码验证，直到到了Widows Service这个选项，将服务的名称修改为不是MySQL就行。例如：MySQL8.</p><p><img src="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/2.png"></p><p>3、然后next，点击finsh即可。</p><p>4、win + r，输入services.msc，找到MySQL8，右键点击属性，叫启动类型修改为手动。</p><p>5、win + r，输入cmd，点击Ctrl + shift + 回车，进入管理员命令界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start MySQL8        //启动本地MySQL服务</span><br><span class="line">net stop MySQL8         //关闭本地MySQL服务</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a><strong>方法二：</strong></h3><p>改变phpstudy的端口为3307，且改变本地mysql的服务名。</p><p>1、按照第一部方法，修改本地mysql的服务名。</p><p>2、打开phpstudy，修改端口</p><p><img src="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/3.png"></p><p><img src="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/4.png"></p><p>3、即可两个mysql同时启动了</p><p><img src="/2024/10/13/%E7%AC%AC%E4%B8%89%E7%AF%87/5.png"></p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> phpstudy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vmware中Linux虚拟机如何扩容</title>
      <link href="/2024/10/13/linux/"/>
      <url>/2024/10/13/linux/</url>
      
        <content type="html"><![CDATA[<h2 id="理解挂载点和分区的关系"><a href="#理解挂载点和分区的关系" class="headerlink" title="理解挂载点和分区的关系"></a>理解挂载点和分区的关系</h2><p>在 Linux 系统中，挂载点（Mount Point）与分区（Partition）是文件系统管理中的两个核心概念，它们之间的关系如下：</p><ol><li><p><strong>分区</strong>：</p><ul><li>分区是指硬盘驱动器上的连续空间，它被划分为独立的区域，每个区域可以用来存储数据。</li><li>分区可以是主分区或扩展分区，扩展分区可以进一步划分为逻辑分区。</li><li>分区通常使用文件系统类型，如 ext4、NTFS、FAT32 等，这些文件系统决定了数据如何在分区上被组织和访问。</li></ul></li><li><p><strong>挂载点</strong>：</p><ul><li>挂载点是文件系统中的一个目录，它是已存在的一个空目录，用来作为分区或其他存储设备（如 USB 闪存驱动器、光盘等）与 Linux 文件系统树的连接点。</li><li>当一个分区被挂载到一个挂载点时，分区上的文件和目录就可以通过挂载点来访问。</li><li>在 Linux 系统中，挂载点可以是任何目录，但通常会在 <code>/mnt</code>、<code>/media</code> 或 <code>/var</code> 等目录下为不同的存储设备创建特定的挂载点。</li></ul></li></ol><p>简单来说：</p><p>例如，一个常见的 Linux 系统分区布局可能包括：</p><ul><li><code>/dev/sda1</code>：根分区（<code>/</code>），挂载到根目录 <code>/</code></li><li><code>/dev/sda2</code>：交换分区（swap），不被直接挂载，而是用于虚拟内存</li><li><code>/dev/sda3</code>：家目录分区（<code>/home</code>），挂载到 <code>/home</code></li><li><code>/dev/sda4</code>：数据分区（<code>/data</code>），挂载到 <code>/data</code></li></ul><h2 id="以Centos举例"><a href="#以Centos举例" class="headerlink" title="以Centos举例"></a>以Centos举例</h2><p>首先确保你的虚拟机，没有快照如果有快照是不能进行扩容的，需要将快照删除掉。</p><p><img src="/2024/10/13/linux/1.png"><br>先给虚拟机分配存储空间，这一步并不意味这你扩容成功了，还需要挂载到目录下，可以理解是windows中的未分配存储空间。</p><p><img src="/2024/10/13/linux/2.png"></p><h3 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h3><p>利用gparted命令，查看存储空间的情况（没有的话执行sudo apt install gparted<br>安装以下，这是一个图形化的工具）</p><p><img src="/2024/10/13/linux/3.png"></p><p>可以看到&#x2F;dev&#x2F;sda就是我们总的存储空间一共有51GB，跟我们设置的一样，但是还不能使用。（每个人的图可能都不样，但是原理是一样的，把中间的全部删除，合并到未分配），&#x2F;dev&#x2F;sda2挂载到了&#x2F;根目录下，大小为48.41GB。&#x2F;dev&#x2F;sda3是linux的交换区，如果没有的话开机会很慢。至于大小可以给1GB（如果存储空间很多的话）或500MB以上。</p><h3 id="进行分配"><a href="#进行分配" class="headerlink" title="进行分配"></a>进行分配</h3><p>那么先要做的就是将未分配的存储添加到&#x2F;dev&#x2F;sda2中但是它们之间隔了交换区那么就根windows一样要想合并那么就必须是两个相邻的盘，才能合并到一块。</p><p>1、右键交换区，选择停用交换空间</p><p>2、右键交换区，选择删除</p><p><img src="/2024/10/13/linux/4.png"></p><p>3、原本的交换区就会合并到未分配区。</p><p>4、右键红色1位置，选择更换大小，就可以将&#x2F;dev&#x2F;sda2进行扩容了，可以输入数据改变大小，或者拉动上面的条条左右移动，向右移扩容，确定好后点击调整大小即可。</p><p><img src="/2024/10/13/linux/5.png"></p><p>5、点击对勾，执行操作。</p><p><img src="/2024/10/13/linux/6.png"></p><p>6、如果你的分区和我不一样，我们还要确保&#x2F;etc&#x2F;fstab文件内容中，每个分区的UUID是正确的。</p><p>什么是&#x2F;etc&#x2F;fstab文件？什么是UUID？</p><p>在 Linux 系统中，<code>/etc/fstab</code>（文件系统表）是一个重要的配置文件，它列出了系统启动时应该自动挂载的文件系统。UUID（Universally Unique Identifier，通用唯一识别码）是一个用于标识信息的 128 位数字，简单来说就是每个分区唯一的标识。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> blkid              //查看真实UUID</span><br><span class="line"></span><br><span class="line">vim /etc/fstab          //修改配置文件，将UUID设置正确</span><br></pre></td></tr></table></figure><p>可以看到我们挂载到&#x2F;根目录和&#x2F;boot的UUID，是没问题的，我这里还有一个swap，后面会配置，只要修改它的UUID即可。现在先不用管，主要看你扩容的分区对应的UUID是不是正确的。</p><p><img src="/2024/10/13/linux/7.png"></p><p>这样就完成了扩容，但是如果不配置交换区的话，开机会很慢（当然还有别的不好）。</p><h3 id="配置交换区"><a href="#配置交换区" class="headerlink" title="配置交换区"></a>配置交换区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 先利用fdisk /dev/sda                  //使用 `fdisk` 命令打开磁盘 `/dev/sda`</span><br><span class="line">- 创建一个新分区sda3                   //一直回车即可</span><br><span class="line">- 将新创建的分区类型设置为 Linux Swap。按下 `t` 键，选择新创建的分区，然后输入对应的类型代码 `82`</span><br><span class="line">- 将分区标记为交换分区。按下 `p` 键查看分区表，记下你所创建的分区名称（例如 `/dev/sda2`），之后按下 `w` 键保存更改并退出 `fdisk`</span><br><span class="line">- 然后开始设置交换分区，  输入命令`mkswap /dev/sda2`</span><br></pre></td></tr></table></figure><p>1、先利用fdisk &#x2F;dev&#x2F;sda                  &#x2F;&#x2F;使用 fdisk 命令打开磁盘 &#x2F;dev&#x2F;sda</p><p><img src="/2024/10/13/linux/8.png"></p><p>2、新建分区sda3</p><p><img src="/2024/10/13/linux/9.png"></p><p>        输入 <code>p</code> 命令将显示当前磁盘的分区信息</p><p>        n命令新建分区</p><p>        选择p创建一个主分区</p><p>        之后一直回车就好（默认剩余空间全部用来当作交换区）</p><p>3、将新建的分区</p><p><img src="/2024/10/13/linux/10.png"></p><p>        命令t为分区设置system id（区分作用的）。</p><p>        选择3，也就是新建准备作为交换区的分区。</p><p>        82是分区类型代码 <code>82</code> 代表交换分区（Linux Swap）。</p><p>        w命令保存。</p><p>4、配置UUID。</p><p><img src="/2024/10/13/linux/11.png"></p><p>        mkswap &#x2F;dev&#x2F;sda3                                     &#x2F;&#x2F;设置交换分区，设置UUID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/fstab                    //修改配置文件</span><br></pre></td></tr></table></figure><p>        这里只修改了第三个swap，如果发现sudo blkid显示出来的UUID和文件里的不一样，那可能是你之前配置有误，修改文件中UUID即可。</p><p><img src="/2024/10/13/linux/12.png"></p><p>        这样就配置好了，当然弄懂上面的原理也可将，新建分区挂载到不同的目录下也行，比如一个新建目录的&#x2F;download，那么你的分区&#x2F;dev&#x2F;sda4（不一定是4，看你新建的是哪个分区）多大，你的&#x2F;download就能放多大的文件。</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vmware </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2子系统如何设置桥接和静态ip</title>
      <link href="/2024/10/13/wsl/"/>
      <url>/2024/10/13/wsl/</url>
      
        <content type="html"><![CDATA[<h2 id="利用Hyper-V创建一个虚拟交换机"><a href="#利用Hyper-V创建一个虚拟交换机" class="headerlink" title="利用Hyper-V创建一个虚拟交换机"></a>利用Hyper-V创建一个虚拟交换机</h2><p>点击 win + s，搜索Hyper-V管理器，点击进去。</p><p><img src="/2024/10/13/wsl/1.png"><br>点击“虚拟交换机管理器”。</p><p><img src="/2024/10/13/wsl/2.png"><br>类型选择“外部”，点击创建虚拟交换机。</p><p><img src="/2024/10/13/wsl/3.png"><br>输入名称，和你所用的网卡，配置完成后，点击应用、确定。</p><p><img src="/2024/10/13/wsl/4.png">​<br>（1）第一次创建，遇到创建不了的问题</p><p><img src="/2024/10/13/wsl/5.png"><br>解决方法<br>首先找到控制面板 -&gt; 查看网络状态和任务 -&gt; 更改适配器设置 -&gt; 找到WLAN（如果不是连接的WIFI，以太网也一样）-&gt; 找到共享选项全部关闭（把勾取消掉）</p><p><img src="/2024/10/13/wsl/6.png"><br>（2）之前有过现在删除重新创建<br><img src="/2024/10/13/wsl/7.png"><br>解决方法<br>win + r 输入control，进入控制面板 -&gt; 查看网络状态和任务 -&gt; 更改适配器设置 -&gt; 找到WLAN（如果不是连接的WIFI，以太网也一样）-&gt; 将Hyper-V可拓展的虚拟机交换机给取消。<br><img src="/2024/10/13/wsl/8.png"></p><h2 id="wslconfig配置文件"><a href="#wslconfig配置文件" class="headerlink" title=".wslconfig配置文件"></a>.wslconfig配置文件</h2><p><code>.wslconfig</code> 是一个用于配置 Windows Subsystem for Linux (WSL) 的配置文件。<code>.wslconfig</code> 文件提供了对 WSL 2 的全局配置选项。这个文件在%Userprofile%（C:\用户\用户名）目录下，如果没有就创建一个。<br>配置信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; 这是 WSL 2 的配置文件</span><br><span class="line"></span><br><span class="line">[wsl2]</span><br><span class="line">processors=4                            ; 设置 WSL 2 可以使用的最大 CPU 核心数为 4，自行修改</span><br><span class="line">memory=4GB                              ; 设置 WSL 2 可以使用的最大内存量为 4 GB，自行修改</span><br><span class="line">swap=4GB                                ; 设置 WSL 2 的交换空间大小为 4 GB，自行修改</span><br><span class="line">localhostForwarding=<span class="literal">true</span>                ; 允许本地主机转发</span><br><span class="line">networkingMode=bridged                  ; 设置网络模式为桥接模式</span><br><span class="line">vmSwitch=WSL                            ; 指定使用的虚拟交换机为 <span class="string">&quot;WSL&quot;</span>，这里填虚拟交换机的名称</span><br><span class="line">ipv6=<span class="literal">true</span>                               ; 启用 IPv6 支持</span><br><span class="line">dhcp=<span class="literal">false</span>                              ; 禁用 DHCP，手动设置网络配置</span><br><span class="line"></span><br><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual               ; 慢慢回收内存</span><br><span class="line">autoProxy=<span class="literal">true</span>                          ; 启用自动代理设置</span><br></pre></td></tr></table></figure><h2 id="etc-netplan目录下生成-yaml文件"><a href="#etc-netplan目录下生成-yaml文件" class="headerlink" title="&#x2F;etc&#x2F;netplan目录下生成*.yaml文件"></a>&#x2F;etc&#x2F;netplan目录下生成*.yaml文件</h2><p>完成以上两步（虽然已经是桥接模式但是WSL2子系统的ip不是固定的，而且可能会与宿主主机的ip相同，那么你在子系统开启的服务，例如：8989端口开启了http服务，那么你在主机是访问不到这个服务的），所以我们还要进一步配置。</p><p>在 Linux 系统中，<code>/etc/netplan</code> 目录下的 <code>.yaml</code> 文件是用于配置网络设置的。</p><p>首先进入，Linux子系统中，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@LAPTOP-GUB0QBS8:/# <span class="built_in">cd</span> /etc/netplan</span><br><span class="line">root@LAPTOP-GUB0QBS8:/etc/netplan# <span class="built_in">ls</span></span><br><span class="line">zwy.yaml                                                 //这里之前已经创建过了</span><br><span class="line">root@LAPTOP-GUB0QBS8:/etc/netplan# <span class="built_in">touch</span> xxx.yaml</span><br><span class="line">root@LAPTOP-GUB0QBS8:/etc/netplan# <span class="built_in">ls</span></span><br><span class="line">xxx.yaml  zwy.yaml</span><br><span class="line">root@LAPTOP-GUB0QBS8:/etc/netplan# nano xxx.yaml         //进行编辑</span><br></pre></td></tr></table></figure><p>编辑内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  ethernets:</span><br><span class="line">    eth0:</span><br><span class="line">      dhcp4: no</span><br><span class="line">      addresses:</span><br><span class="line">        - 192.168.1.223/24   <span class="comment"># 设置一个不与主机相同的IP地址</span></span><br><span class="line">      gateway4: 192.168.1.1  <span class="comment"># 设置网关地址</span></span><br><span class="line">      nameservers:           <span class="comment">#dns服务，这下面可以跟我一样</span></span><br><span class="line">          addresses:</span><br><span class="line">              - 8.8.8.8</span><br><span class="line">              - 8.8.4.4</span><br><span class="line">              - 223.5.5.5  <span class="comment"># 添加中国移动公共DNS服务器地址</span></span><br><span class="line">              - 223.6.6.6  <span class="comment"># 添加中国移动公共DNS服务器地址</span></span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>查看，Linux子系统的ip（这样就配置完成了），且如果用Vmware创建的虚拟机是桥接模式，它们之间是可以相互ping通的。<br><img src="/2024/10/13/wsl/9.png"></p><p>这里还用关于WSL一些操作的笔记，可以下来看看，用的Xmind这款软件做的笔记。<br><a href="https://www.123pan.com/s/WK4vTd-dapn.html" title="https://www.123pan.com/s/WK4vTd-dapn.html">https://www.123pan.com/s/WK4vTd-dapn.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL2 </tag>
            
            <tag> Hyper-V </tag>
            
            <tag> 静态ip </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
